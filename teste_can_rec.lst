CCS PCM C Compiler, Version 5.015, 5967               22-jul-20 16:17

               Filename:   c:\Users\fernandoLab\Documents\GitHub\Rede-CAN-PIC\teste_can_rec.lst

               ROM used:   1624 words (79%)
                           Largest free fragment is 423
               RAM used:   27 (21%) at main() level
                           108 (84%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   57B
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   20,W
0008:  MOVWF  24
0009:  MOVF   21,W
000A:  MOVWF  25
000B:  MOVF   22,W
000C:  MOVWF  26
000D:  MOVF   23,W
000E:  MOVWF  27
000F:  BTFSS  0B.4
0010:  GOTO   013
0011:  BTFSC  0B.1
0012:  GOTO   03C
0013:  CLRF   05
0014:  MOVLW  91
0015:  MOVWF  04
0016:  BTFSS  00.0
0017:  GOTO   01A
0018:  BTFSC  11.0
0019:  GOTO   023
001A:  MOVF   24,W
001B:  MOVWF  20
001C:  MOVF   25,W
001D:  MOVWF  21
001E:  MOVF   26,W
001F:  MOVWF  22
0020:  MOVF   27,W
0021:  MOVWF  23
0022:  RETFIE
.................... #include <teste_can_rec.h> 
.................... #include <16F1823.h> 
.................... //////////// Standard Header file for the PIC16F1823 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1823 
*
00A3:  MOVF   21,W
00A4:  BTFSC  03.2
00A5:  GOTO   0AA
00A6:  MOVF   20,W
00A7:  MOVWI  W,[FSR0++]
00A8:  DECFSZ 21,F
00A9:  GOTO   0A6
00AA:  RETURN
*
0525:  MOVF   3F,W
0526:  ANDLW  07
0527:  MOVWF  20
0528:  RRF    3F,W
0529:  MOVWF  21
052A:  RRF    21,F
052B:  RRF    21,F
052C:  MOVLW  1F
052D:  ANDWF  21,F
052E:  MOVF   21,W
052F:  ADDWF  41,W
0530:  MOVWF  04
0531:  MOVLW  00
0532:  ADDWFC 42,W
0533:  MOVWF  05
0534:  CLRF   21
0535:  INCF   21,F
0536:  INCF   20,F
0537:  GOTO   539
0538:  RLF    21,F
0539:  DECFSZ 20,F
053A:  GOTO   538
053B:  MOVF   40,F
053C:  BTFSC  03.2
053D:  GOTO   541
053E:  MOVF   21,W
053F:  IORWF  00,F
0540:  GOTO   544
0541:  COMF   21,F
0542:  MOVF   21,W
0543:  ANDWF  00,F
0544:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(internal=4000000) 
*
0040:  MOVLW  20
0041:  MOVWF  05
0042:  MOVWF  04
0043:  MOVF   00,W
0044:  BTFSC  03.2
0045:  GOTO   054
0046:  MOVLW  01
0047:  MOVWF  21
0048:  CLRF   20
0049:  DECFSZ 20,F
004A:  GOTO   049
004B:  DECFSZ 21,F
004C:  GOTO   048
004D:  MOVLW  4A
004E:  MOVWF  20
004F:  DECFSZ 20,F
0050:  GOTO   04F
0051:  GOTO   052
0052:  DECFSZ 00,F
0053:  GOTO   046
0054:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=1,bits=8,stream=PORT1) 
....................  
.................... #define LED1 PIN_A5 
.................... #define LED2 PIN_A4 
.................... #define SAIDA1 PIN_C5 
....................  
.................... // PORTA 
.................... #define   IRQ         PIN_A2 
.................... #define   CE          PIN_A1 
.................... #define   MCLR        PIN_A3 
.................... // PORTC 
.................... #define   SCK         PIN_C0 
.................... #define   SDI         PIN_C1 
.................... #define   SDO         PIN_C2 
.................... #define   CS          PIN_C3 
....................                        
.................... //TRISA 
.................... #define   CE_TRIS     TRISA,1 //O 
.................... #define   IRQ_TRIS    TRISA,2 //I 
....................  
.................... //TRISC 
.................... #define   SCK_TRIS    TRISC,0 //O 
.................... #define   SDI_TRIS    TRISC,1 //I 
.................... #define   SDO_TRIS    TRISC,2 //O 
.................... #define   CS_TRIS     TRISC,3 //O 
....................  
.................... //***************** 
.................... //*   VARIABLES   * 
.................... //***************** 
.................... #BYTE TRISA     =  0x0C //00000110 
.................... //#BYTE TRISB     =  0x86 
.................... #BYTE TRISC     =  0x02 //00000010 
.................... #BYTE INTCON    =  0x00 
....................  
.................... #include <can-mcp2515.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-mcp2510.c                            //// 
.................... //// CAN Library routines for Microchip's MCP2510 (and compatable)   //// 
.................... //// CAN IO expanders.                                               //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the MCP2510 CAN peripheral             //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// You will need a CAN transeiver to connect CANRX and CANTX       //// 
.................... //// pins to CANH and CANL bus lines.                                //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can_ccs_b.c, which shows how to use //// 
.................... //// this library with CCS's CAN Prototype board.                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 04 - Fixed a compling problem.                          //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 17 09 - Updated for PCD Compiler                           //// 
.................... ////                                                                 //// 
.................... ////  May 20 10 - Changed all variable types to unsigned for PCD and //// 
.................... ////              if #device ANSI is used with PCH or PCM            //// 
.................... ////                                                                 //// 
.................... ////  Nov 10 10 - Modified SPI protocol to use #use SPI()            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-mcp2515.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-mcp2510.h                            //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for the MCP2510 (and compatable) CAN IO     //// 
.................... //// expanders.                                                      //// 
.................... ////                                                                 //// 
.................... //// (see can-mcp2510.c)                                             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 04 - Fixed a compling problem                           //// 
.................... ////                                                                 //// 
.................... ////  Jul 17 09 - Updated for PCD Compiler                           //// 
.................... ////                                                                 //// 
.................... ////  May 20 10 - Changed all variable types to unsigned for PCD and //// 
.................... ////              if #device ANSI is used with PCH or PCM            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... //#define CAN_DO_DEBUG TRUE 
....................  
....................  
.................... //defines BAUD RATE 
....................  
.................... #define MCP_8MHz_500kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_500kBPS_CFG2 (0x90) 
.................... #define MCP_8MHz_500kBPS_CFG3 (0x02) 
....................  
.................... #define MCP_8MHz_250kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_250kBPS_CFG2 (0xb1) 
.................... #define MCP_8MHz_250kBPS_CFG3 (0x05) 
....................  
.................... #define MCP_8MHz_200kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_200kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_200kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_125kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_125kBPS_CFG2 (0xb1) 
.................... #define MCP_8MHz_125kBPS_CFG3 (0x05) 
....................  
.................... #define MCP_8MHz_100kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_100kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_100kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_80kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_80kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_80kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_50kBPS_CFG1 (0x03) 
.................... #define MCP_8MHz_50kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_50kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_40kBPS_CFG1 (0x03) 
.................... #define MCP_8MHz_40kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_40kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_20kBPS_CFG1 (0x07) 
.................... #define MCP_8MHz_20kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_20kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_10kBPS_CFG1 (0x0f) 
.................... #define MCP_8MHz_10kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_10kBPS_CFG3 (0x07) 
....................  
....................  
....................  
.................... #ifndef __CCS_CANMCP2510_LIB_DEFINES__ 
.................... #define __CCS_CANMCP2510_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         FALSE 
.................... #ENDIF 
....................  
.................... /////////////// register CNF1  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... ////BRP 
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   int8 CAN_BRG_PRESCALAR = 0;  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... /////////////// register CNF2 
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... ////PS1 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  int8 CAN_BRG_PHASE_SEGMENT_1 = 1; //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... ////PSG    
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  int8 CAN_BRG_PROPAGATION_TIME = 1; //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... /////////////// register CNF3 
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... ////PS2 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  int8 CAN_BRG_PHASE_SEGMENT_2 = 2; //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_SLEEP=1, CAN_OP_NORMAL=0}; 
....................  
.................... //can control 
.................... struct struct_CANCTRL { 
....................    int  clkpre:2; //0:1 //clkout pin prescalar 
....................    int1 clken; //2   //clkout pin enable 
....................    int1 osm; //3 
....................    int1 abat;  //4   //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3; //5:7 //request operation mode 
.................... }; 
.................... #define CANCTRL   0x0F  //or 1f, or 2f, or 3f ... or 7f 
....................  
.................... enum CAN_INT_CODE {CAN_INT_RX1=7, CAN_INT_RX0=6, CAN_INT_TX2=5, CAN_INT_TX1=4, CAN_INT_TX0=3, CAN_INT_WAKEUP=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct struct_CANSTAT { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... }; 
.................... #define CANSTAT 0x0E //or 1e, or 2e ... or 7e 
....................  
.................... //error flag register 
.................... struct struct_EFLG { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwar;      //1 //receiver warning 
....................    int1 txwar;      //2 //transmitter warning 
....................    int1 rxep;   //3 //receive error passive flag 
....................    int1 txep;   //4 //transmit error passive flag 
....................    int1 txbo;   //5   //bus off error flag 
....................    int1 rx0ovr;   //6   //receive buffer 0 overflow 
....................    int1 rx1ovr;   //7   //receive buffer 1 overflow 
.................... }; 
.................... #define EFLG   0x2D 
....................  
.................... //interupt enable register 
.................... struct struct_CANINTE { 
....................    int1 rx0ie; //0   //receive buffer 0 full interrupt enable 
....................    int1 rx1ie; //1   //receive buffer 1 full interrupt enable 
....................    int1 tx0ie; //2   //transmit buffer 0 embty interrupt enable 
....................    int1 tx1ie; //3   //transmit buffer 1 embty interrupt enable 
....................    int1 tx2ie; //4   //transmit buffer 2 embty interrupt enable 
....................    int1 errie; //5   //error interrupt enable 
....................    int1 wakie; //6   //wakeup interrupt  enable 
....................    int1 merre; //7   //message error interrupt enable 
.................... }; 
.................... #define CANINTE   0x2B 
....................  
.................... //interupt enable register 
.................... struct struct_CANINTF { 
....................    int1 rx0if; //0   //receive buffer 0 full interrupt flag 
....................    int1 rx1if; //1   //receive buffer 1 full interrupt flag 
....................    int1 tx0if; //2   //transmit buffer 0 embty interrupt flag 
....................    int1 tx1if; //3   //transmit buffer 1 embty interrupt flag 
....................    int1 tx2if; //4   //transmit buffer 2 embty interrupt flag 
....................    int1 errif; //5   //error interrupt flag 
....................    int1 wakif; //6   //wakeup interrupt flag 
....................    int1 merrf; //7   //message error interrupt flag 
.................... }; 
.................... #define CANINTF   0x2C 
....................  
.................... #DEFINE CAN_RX0_INT    1 
.................... #DEFINE CAN_RX1_INT    2 
.................... #DEFINE CAN_TX0_INT    4 
.................... #DEFINE CAN_TX1_INT    8  
.................... #DEFINE CAN_TX2_INT    16 
.................... #DEFINE CAN_ERROR_INT  32 
.................... #DEFINE CAN_WAKE_INT   64 
.................... #DEFINE CAN_MESERR_INT 128 
....................  
.................... //error counters 
.................... #define TEC    0x1C 
.................... #define REC    0x1D 
....................  
.................... //baud rate control register 1 
.................... struct struct_CNF1 { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... }; 
.................... #define CNF1   0x2A 
....................  
.................... //baud rate control register 2 
.................... struct struct_CNF2 { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int phseg1:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 btlmode; //7 //phase segment 2 bit time length 
.................... }; 
.................... #define CNF2   0x29 
....................  
.................... //baud rate control register 3 
.................... struct struct_CNF3 { 
....................    int phseg2:3;     //0:2 //phase segment 2 time select 
....................    int void543:3;    //3:5 
....................    int1 wakfil;      //6   //selects can bus line filter for wake-up 
....................    int1 sof;         //7 
.................... }; 
.................... #define CNF3   0x28 
.................... //can i/o control register 
....................  
.................... //transmit buffer n control register 
.................... struct txbNctrl_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 mloa;   //5   //message lost arbitration 
....................    int1 abtf;   //6   //message was aborted / or transmitted succesfully 
....................    int1 void7; 
.................... }; 
.................... #define TXB0CTRL  0x30 
.................... #define TXB1CTRL  0x40 
.................... #define TXB2CTRL  0x50 
....................  
.................... //TXnRTS pin control and status register 
.................... struct struct_TXRTSCTRL { 
....................    int1 b0rtsm; //0  //1=request message trans, 0=digital 
....................    int1 b1rtsm; //1  //1=request message trans, 0=digital 
....................    int1 b2rtsm; //2  //1=request message trans, 0=digital 
....................    int1 b0rts; //3   //reads as tx2rts when in digital, 0 when in rts 
....................    int1 b1rts; //4   //reads as tx2rts when in digital, 0 when in rts mode 
....................    int1 b2rts; //5  //reads as tx2rts when in digital, 0 when in rts mode 
....................    int  void67:2; //6:7 
.................... }; 
.................... #define TXRTSCTRL 0x0D 
....................  
.................... //transmit buffer n standard identifier 
.................... #define TXB0SIDH 0x31 
.................... #define TXB0SIDL 0x32 
.................... #define TXB1SIDH 0x41 
.................... #define TXB1SIDL 0x42 
.................... #define TXB2SIDH 0x51 
.................... #define TXB2SIDL 0x52 
....................  
.................... //transmit buffer n extended identifier 
.................... #define TXB0EIDH 0x33 
.................... #define TXB0EIDL 0x34 
.................... #define TXB1EIDH 0x43 
.................... #define TXB1EIDL 0x44 
.................... #define TXB2EIDH 0x53 
.................... #define TXB2EIDL 0x54 
....................  
.................... //transmit buffer n data byte m 
.................... #define TXB0D0 0x36 
.................... #define TXB0D7 0x3D 
....................  
.................... #define TXB1D0 0x46 
.................... #define TXB1D7 0x4D 
....................  
.................... #define TXB2D0 0x56 
.................... #define TXB2D7 0x5D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... #define TXB0DLC 0x35 
.................... #define TXB1DLC 0x45 
.................... #define TXB2DLC 0x55 
....................  
.................... //#byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct struct_RXB0CTRL { 
....................    int1 filhit0;   //0 //filter hit 
....................    int1 bukt1;   //1 //read only copy of bukt bit (used internally by mcp2510) 
....................    int1 bukt;   //2 //rollover enable 
....................    int1 rxrtr;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 void7;   //7 //receive full status 
.................... }; 
.................... #define RXB0CTRL  0x60 
....................  
.................... //receive buffer 1 control register 
.................... struct struct_RXB1CTRL { 
....................    int filhit0:3;   //0:2 
....................    int1 rxrtr;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 void7;   //7 
.................... }; 
.................... #define RXB1CTRL 0x70 
....................  
.................... //RXnBF pint control and status register 
.................... struct struct_BFPCTRL { 
....................    int1  b0bfm; //0   //1=pin is interrupt when message loaded into rxb0, 0=digital 
....................    int1  b1bfm; //1   //1=pin is interrupt when message loaded into rxb1, 0=digital 
....................    int1  b0bfe; //2   //rx0bf pin function enable 
....................    int1  b1bfe; //3   //rx1bf pin function enable 
....................    int1  b0bfs; //4   //rx0bf pin state 
....................    int1  b1bfs; //5   //rx1bf pin state 
.................... }; 
....................  
.................... //receive buffer n standard identifier 
.................... #define   RXB0SIDH  0x61 
.................... #define   RXB0SIDL  0x62 
....................  
.................... #define   RXB1SIDH  0x71 
.................... #define   RXB1SIDL  0x72 
....................  
.................... //receive buffer n extended identifier 
.................... #define   RXB0EID8  0x63 
.................... #define   RXB0EID0  0x64 
....................  
.................... #define   RXB1EID8  0x73 
.................... #define   RXB1EID0  0x74 
....................  
.................... struct struct_TXRXBaSIDL { 
....................    int void012:3; //0:2 
....................    int1 ext;      //3 //extendid id 
....................    int1 srr;      //4 //substitute remove request bit 
....................    int void567:3; //5:7 
.................... }; 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0;   //4   //reserved 
....................    int1 rb1;   //5   //reserved 
....................    int1 rtr;   //6   //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... #define   RXB0DLC   0x65 
.................... #define   RXB1DLC   0x75 
....................  
.................... //receive buffer n data field byte m register 
.................... #define RXB0D0    0x66 
.................... #define RXB0D7    0x6D 
....................  
.................... #define RXB1D0    0x76 
.................... #define RXB1D7    0x7D 
....................  
....................  
.................... //receive acceptance filter n standard indifier 
.................... #define RXF0SIDH  0x00 
.................... #define RXF0SIDL  0x01 
.................... #define RXF1SIDH  0x04 
.................... #define RXF1SIDL  0x05 
.................... #define RXF2SIDH  0x08 
.................... #define RXF2SIDL  0x09 
.................... #define RXF3SIDH  0x10 
.................... #define RXF3SIDL  0x11 
.................... #define RXF4SIDH  0x14 
.................... #define RXF4SIDL  0x15 
.................... #define RXF5SIDH  0x18 
.................... #define RXF5SIDL  0x19 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #define RXF0EIDH  0x02 
.................... #define RXF0EIDL  0x03 
.................... #define RXF1EIDH  0x06 
.................... #define RXF1EIDL  0x07 
.................... #define RXF2EIDH  0x0a 
.................... #define RXF2EIDL  0x0b 
.................... #define RXF3EIDH  0x12 
.................... #define RXF3EIDL  0x13 
.................... #define RXF4EIDH  0x16 
.................... #define RXF4EIDL  0x17 
.................... #define RXF5EIDH  0x1a 
.................... #define RXF5EIDL  0x1b 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #define RXM0SIDH  0x20 
.................... #define RXM0SIDL  0x21 
.................... #define RXM1SIDH  0x24 
.................... #define RXM1SIDL  0x25 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #define RXM0EIDH  0x22 
.................... #define RXM0EIDL  0x23 
.................... #define RXM1EIDH  0x26 
.................... #define RXM1EIDL  0x27 
....................  
.................... #define RX0MASK       RXM0EIDL   //rxm0eidl 
.................... #define RX1MASK       RXM1EIDL   //rxm1eidl 
.................... #define RX0FILTER0    RXF0EIDL   //rxf0eidl 
.................... #define RX0FILTER1    RXF1EIDL   //rxf1eidl 
.................... #define RX1FILTER2    RXF2EIDL   //rxf2eidl 
.................... #define RX1FILTER3    RXF3EIDL   //rxf3eidl 
.................... #define RX1FILTER4    RXF4EIDL   //rxf4eidl 
.................... #define RX1FILTER5    RXF5EIDL   //rxf5eidl 
.................... #define RXB0ID        RXB0EIDL   //rxb0eidl 
.................... #define RXB1ID        RXB1EIDL   //rxb1eidl 
.................... #define TXB0ID        TXB0EIDL   //txb0eidl 
.................... #define TXB1ID        TXB1EIDL   //txb1eidl 
.................... #define TXB2ID        TXB2EIDL   //tsb2eidl 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
....................  
.................... //PROTOTYPES and MACROS 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void can_set_id(unsigned int8 addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int8 addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int8 * data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int8 * data, unsigned int8 & len, struct rx_stat & stat); 
....................  
.................... void mcp2510_init(); 
.................... void mcp2510_command(unsigned int8 command); 
.................... void mcp2510_write(unsigned int8 address, unsigned int8 data); 
.................... unsigned int8 mcp2510_status(void); 
.................... unsigned int8 mcp2510_read(unsigned int8 address); 
....................  
.................... #endif 
....................  
....................  
.................... //IO pins connected to MCP2510 
.................... #ifndef EXT_CAN_CS 
....................    #if defined(__PCD__) 
....................       #define EXT_CAN_CS   CS 
....................       #define EXT_CAN_SI   SDI 
....................       #define EXT_CAN_SO   SDO 
....................       #define EXT_CAN_SCK  SCK 
....................    #else 
....................       #define EXT_CAN_CS   CS 
....................       #define EXT_CAN_SI   SDI 
....................       #define EXT_CAN_SO   SDO 
....................       #define EXT_CAN_SCK  SCK 
....................    #endif 
.................... //   #define EXT_CAN_RESET   PIN_B5 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX0RTS  PIN_C4 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX1RTS  PIN_B4 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX2RTS  PIN_C2 //CCS library does not use this pin by default 
.................... #endif 
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes MCP2510 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages). 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE, etc) are given a default define in the can-mcp2510.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) 
.................... { 
....................    struct struct_RXB0CTRL b_rxb0ctrl; 
....................     
....................    mcp2510_init(); 
....................     
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01D9:  MOVLW  04
01DA:  MOVWF  3B
01DB:  CALL   0CA
....................    can_set_baud(); 
....................     
....................    memset(&b_rxb0ctrl,0,1); 
*
0211:  MOVLW  20
0212:  MOVWF  05
0213:  MOVLW  1A
0214:  MOVWF  04
0215:  CLRF   20
0216:  MOVLW  01
0217:  MOVWF  21
0218:  CALL   0A3
....................    // b_rxb0ctrl=0; 
....................    b_rxb0ctrl.rxm=CAN_RX_VALID; 
0219:  MOVLW  9F
021A:  ANDWF  3A,W
021B:  MOVWF  3A
....................    b_rxb0ctrl.bukt=CAN_USE_RX_DOUBLE_BUFFER; 
021C:  BSF    3A.2
....................    mcp2510_write(RXB0CTRL, (unsigned int8)b_rxb0ctrl); 
021D:  MOVLW  60
021E:  MOVWF  66
021F:  MOVF   3A,W
0220:  MOVWF  67
0221:  CALL   0AB
....................    mcp2510_write(RXB1CTRL, (unsigned int8)b_rxb0ctrl); 
0222:  MOVLW  70
0223:  MOVWF  66
0224:  MOVF   3A,W
0225:  MOVWF  67
0226:  CALL   0AB
....................  
....................    //if you want to configure the TXnRTS pins, do it here.  default is off 
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 (RX BUFFER 0) 
0227:  MOVLW  23
0228:  MOVWF  3B
0229:  CLRF   3F
022A:  CLRF   3E
022B:  CLRF   3D
022C:  CLRF   3C
022D:  CLRF   40
022E:  CALL   101
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 (RX BUFFER 0) 
022F:  MOVLW  03
0230:  MOVWF  3B
0231:  CLRF   3F
0232:  CLRF   3E
0233:  CLRF   3D
0234:  CLRF   3C
0235:  CLRF   40
0236:  CALL   101
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 (RX BUFFER 0) 
0237:  MOVLW  07
0238:  MOVWF  3B
0239:  CLRF   3F
023A:  CLRF   3E
023B:  CLRF   3D
023C:  CLRF   3C
023D:  CLRF   40
023E:  CALL   101
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 (RX BUFFER 1) 
023F:  MOVLW  27
0240:  MOVWF  3B
0241:  CLRF   3F
0242:  CLRF   3E
0243:  CLRF   3D
0244:  CLRF   3C
0245:  CLRF   40
0246:  CALL   101
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 (RX BUFFER 1) 
0247:  MOVLW  0B
0248:  MOVWF  3B
0249:  CLRF   3F
024A:  CLRF   3E
024B:  CLRF   3D
024C:  CLRF   3C
024D:  CLRF   40
024E:  CALL   101
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 (RX BUFFER 1) 
024F:  MOVLW  13
0250:  MOVWF  3B
0251:  CLRF   3F
0252:  CLRF   3E
0253:  CLRF   3D
0254:  CLRF   3C
0255:  CLRF   40
0256:  CALL   101
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 (RX BUFFER 1) 
0257:  MOVLW  17
0258:  MOVWF  3B
0259:  CLRF   3F
025A:  CLRF   3E
025B:  CLRF   3D
025C:  CLRF   3C
025D:  CLRF   40
025E:  CALL   101
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 (RX BUFFER 1) 
025F:  MOVLW  1B
0260:  MOVWF  3B
0261:  CLRF   3F
0262:  CLRF   3E
0263:  CLRF   3D
0264:  CLRF   3C
0265:  CLRF   40
0266:  CALL   101
....................        
....................    can_set_mode(CAN_OP_NORMAL); 
0267:  CLRF   3B
0268:  CALL   0CA
0269:  MOVLP  00
026A:  GOTO   5C0 (RETURN)
.................... } 
....................  
.................... //caso vazio(0xFF), por padrão a velocidade é 500kbps 
.................... //// CAN Rate     ####################################### 
.................... //// 500Kbps ---- BRP = 0 / PS1  = 1 /  PSG = 1 / PS2 = 2 
.................... //// 250Kbps ---- BRP = 1 / PS1  = 1 /  PSG = 2 / PS2 = 1 
.................... //// 200Kbps ---- BRP = 1 / PS1  = 2 /  PSG = 2 / PS2 = 2 
.................... //// 125Kbps ---- BRP = 1 / PS1  = 5 /  PSG = 5 / PS2 = 2 
.................... //// 80Kbps ----- BRP = 4 / PS1  = 2 /  PSG = 2 / PS2 = 2 
.................... //// 50Kbps ----- BRP = 4 / PS1  = 5 /  PSG = 2 / PS2 = 5 
.................... ////              ####################################### 
.................... void set_freq_var(int8 freq) 
.................... { 
....................    switch(freq) 
....................    { 
....................       case 0x00: //500kbps (PADRÃO) 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 1; 
....................          CAN_BRG_PROPAGATION_TIME = 1; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x01: //250kbps 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 4; 
....................          CAN_BRG_PROPAGATION_TIME = 3; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 5; 
....................          break; 
....................           
....................       case 0x02: //200kbps 
....................          CAN_BRG_PRESCALAR = 1; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 2; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x03: //125kbps 
....................          CAN_BRG_PRESCALAR = 1; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 5; 
....................          CAN_BRG_PROPAGATION_TIME = 5; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x04: //80kbps 
....................          CAN_BRG_PRESCALAR = 4; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 2; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x5: //50kbps 
....................          CAN_BRG_PRESCALAR = 4; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 5; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 5; 
....................          break; 
....................           
....................       default: //500kbps 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 1; 
....................          CAN_BRG_PROPAGATION_TIME = 1; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2;  
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-mcp2510.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with CCS's CAN Prototype board and 
.................... // Microchip's MCP250xxx CAN Developers Kit if this PIC is running at 8Mhz. 
.................... //   Paramaters: 
.................... //     freq - caso seja 0, seta baud padrão de 500kbps. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud()  
.................... { 
....................    struct struct_CNF1 new_CNF1; 
....................    struct struct_CNF2 new_CNF2; 
....................    struct struct_CNF3 new_CNF3; 
....................  
....................     
....................    new_CNF1.brp=CAN_BRG_PRESCALAR; 
*
01DC:  MOVF   28,W
01DD:  ANDLW  3F
01DE:  MOVWF  20
01DF:  MOVLW  C0
01E0:  ANDWF  3B,W
01E1:  IORWF  20,W
01E2:  MOVWF  3B
....................    new_CNF1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01E3:  MOVLW  3F
01E4:  ANDWF  3B,W
01E5:  MOVWF  3B
....................  
....................    new_CNF2.prseg=CAN_BRG_PROPAGATION_TIME; 
01E6:  MOVF   2A,W
01E7:  ANDLW  07
01E8:  MOVWF  20
01E9:  MOVLW  F8
01EA:  ANDWF  3C,W
01EB:  IORWF  20,W
01EC:  MOVWF  3C
....................    new_CNF2.phseg1=CAN_BRG_PHASE_SEGMENT_1; 
01ED:  MOVF   29,W
01EE:  ANDLW  07
01EF:  MOVWF  20
01F0:  LSLF   20,F
01F1:  RLF    20,F
01F2:  RLF    20,F
01F3:  MOVLW  C7
01F4:  ANDWF  3C,W
01F5:  IORWF  20,W
01F6:  MOVWF  3C
....................    new_CNF2.sam=CAN_BRG_SAM; 
01F7:  BCF    3C.6
....................    new_CNF2.btlmode=CAN_BRG_SEG_2_PHASE_TS; 
01F8:  BSF    3C.7
....................  
....................    new_CNF3.phseg2=CAN_BRG_PHASE_SEGMENT_2; 
01F9:  MOVF   2B,W
01FA:  ANDLW  07
01FB:  MOVWF  20
01FC:  MOVLW  F8
01FD:  ANDWF  3D,W
01FE:  IORWF  20,W
01FF:  MOVWF  3D
....................    new_CNF3.wakfil=CAN_BRG_WAKE_FILTER; 
0200:  BCF    3D.6
....................    new_CNF3.sof=0; 
0201:  BCF    3D.7
....................  
....................    mcp2510_write(CNF1, (unsigned int8)new_CNF1); 
0202:  MOVLW  2A
0203:  MOVWF  66
0204:  MOVF   3B,W
0205:  MOVWF  67
0206:  CALL   0AB
....................    mcp2510_write(CNF2, (unsigned int8)new_CNF2); 
0207:  MOVLW  29
0208:  MOVWF  66
0209:  MOVF   3C,W
020A:  MOVWF  67
020B:  CALL   0AB
....................    mcp2510_write(CNF3, (unsigned int8)new_CNF3); 
020C:  MOVLW  28
020D:  MOVWF  66
020E:  MOVF   3D,W
020F:  MOVWF  67
0210:  CALL   0AB
....................  
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG1); 
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG2); 
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG3); 
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) 
.................... { 
....................    struct struct_CANCTRL old_CANCTRL; 
....................    struct struct_CANSTAT new_CANSTAT; 
....................                                                         
....................    memset(&old_CANCTRL,mcp2510_read(CANCTRL),1); 
*
00CA:  MOVLW  0F
00CB:  MOVLB  01
00CC:  MOVWF  25
00CD:  MOVLB  00
00CE:  CALL   080
00CF:  MOVF   21,W
00D0:  MOVWF  3E
00D1:  MOVLW  20
00D2:  MOVWF  05
00D3:  MOVLW  1C
00D4:  MOVWF  04
00D5:  MOVF   21,W
00D6:  MOVWF  20
00D7:  MOVLW  01
00D8:  MOVWF  21
00D9:  CALL   0A3
....................    //old_CANCTRL=mcp2510_read(CANCTRL); 
....................     
....................    old_CANCTRL.reqop=mode; 
00DA:  SWAPF  3B,W
00DB:  ANDLW  70
00DC:  MOVWF  20
00DD:  LSLF   20,F
00DE:  MOVLW  1F
00DF:  ANDWF  3C,W
00E0:  IORWF  20,W
00E1:  MOVWF  3C
....................    old_CANCTRL.osm=1;//one shot mode 
00E2:  BSF    3C.3
....................  
....................    mcp2510_write(CANCTRL, (unsigned int8)old_CANCTRL); 
00E3:  MOVLW  0F
00E4:  MOVWF  66
00E5:  MOVF   3C,W
00E6:  MOVWF  67
00E7:  CALL   0AB
....................  
....................    do 
....................    { 
....................       memset(&new_CANSTAT,mcp2510_read(CANSTAT),1); 
00E8:  MOVLW  0E
00E9:  MOVLB  01
00EA:  MOVWF  25
00EB:  MOVLB  00
00EC:  CALL   080
00ED:  MOVF   21,W
00EE:  MOVWF  3E
00EF:  MOVLW  20
00F0:  MOVWF  05
00F1:  MOVLW  1D
00F2:  MOVWF  04
00F3:  MOVF   21,W
00F4:  MOVWF  20
00F5:  MOVLW  01
00F6:  MOVWF  21
00F7:  CALL   0A3
....................       //old_CANCTRL=mcp2510_read(CANCTRL);      
....................    } while (new_CANSTAT.opmode != mode); 
00F8:  MOVF   3D,W
00F9:  MOVWF  20
00FA:  SWAPF  20,F
00FB:  LSRF   20,W
00FC:  ANDLW  07
00FD:  SUBWF  3B,W
00FE:  BTFSS  03.2
00FF:  GOTO   0E8
0100:  RETURN
....................   
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int8 addr, unsigned int32 id, int1 ext) 
.................... { 
....................    unsigned int8 converted_id[4]; 
....................    unsigned int8 *ptr; 
....................  
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh 
0101:  MOVLW  20
0102:  MOVWF  46
0103:  MOVLW  24
0104:  MOVWF  45
....................  
....................    if (ext) 
0105:  MOVF   40,F
0106:  BTFSC  03.2
0107:  GOTO   15A
....................    {  //extended 
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0108:  MOVF   45,W
0109:  MOVWF  04
010A:  MOVF   46,W
010B:  MOVWF  05
010C:  MOVF   3C,W
010D:  MOVWF  00
....................  
....................       //eidh 
....................       ptr--; 
010E:  MOVF   45,W
010F:  BTFSC  03.2
0110:  DECF   46,F
0111:  DECF   45,F
....................       *ptr=make8(id,1); //8:15 
0112:  MOVF   45,W
0113:  MOVWF  04
0114:  MOVF   46,W
0115:  MOVWF  05
0116:  MOVF   3D,W
0117:  MOVWF  00
....................  
....................       //sidl 
....................       ptr--; 
0118:  MOVF   45,W
0119:  BTFSC  03.2
011A:  DECF   46,F
011B:  DECF   45,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
011C:  MOVF   45,W
011D:  MOVWF  04
011E:  MOVF   46,W
011F:  MOVWF  05
0120:  MOVF   3E,W
0121:  ANDLW  03
0122:  MOVWF  00
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
0123:  MOVF   45,W
0124:  MOVWF  04
0125:  MOVF   46,W
0126:  MOVWF  05
0127:  MOVF   3E,W
0128:  MOVWF  20
0129:  RLF    20,F
012A:  RLF    20,F
012B:  RLF    20,F
012C:  MOVLW  F8
012D:  ANDWF  20,F
012E:  MOVF   20,W
012F:  ANDLW  E0
0130:  IORWF  00,W
0131:  MOVWF  00
....................       *ptr|=0x08; 
0132:  MOVF   45,W
0133:  MOVWF  04
0134:  MOVF   46,W
0135:  MOVWF  05
0136:  MOVF   00,W
0137:  IORLW  08
0138:  MOVWF  00
....................  
....................  
....................       //sidh 
....................       ptr--; 
0139:  MOVF   45,W
013A:  BTFSC  03.2
013B:  DECF   46,F
013C:  DECF   45,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
013D:  MOVF   45,W
013E:  MOVWF  04
013F:  MOVF   46,W
0140:  MOVWF  05
0141:  MOVF   3E,W
0142:  MOVWF  20
0143:  SWAPF  20,F
0144:  RRF    20,F
0145:  MOVLW  07
0146:  ANDWF  20,F
0147:  MOVF   20,W
0148:  ANDLW  07
0149:  MOVWF  00
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
014A:  MOVF   45,W
014B:  MOVWF  04
014C:  MOVF   46,W
014D:  MOVWF  05
014E:  MOVF   3F,W
014F:  MOVWF  20
0150:  RLF    20,F
0151:  RLF    20,F
0152:  RLF    20,F
0153:  MOVLW  F8
0154:  ANDWF  20,F
0155:  MOVF   20,W
0156:  ANDLW  F8
0157:  IORWF  00,W
0158:  MOVWF  00
....................    } 
0159:  GOTO   199
....................    else  
....................    {   //standard 
....................       //eidl 
....................       *ptr=0; 
015A:  MOVF   45,W
015B:  MOVWF  04
015C:  MOVF   46,W
015D:  MOVWF  05
015E:  CLRF   00
....................  
....................       //eidh 
....................       ptr--; 
015F:  MOVF   45,W
0160:  BTFSC  03.2
0161:  DECF   46,F
0162:  DECF   45,F
....................       *ptr=0; 
0163:  MOVF   45,W
0164:  MOVWF  04
0165:  MOVF   46,W
0166:  MOVWF  05
0167:  CLRF   00
....................  
....................       //sidl 
....................       ptr--; 
0168:  MOVF   45,W
0169:  BTFSC  03.2
016A:  DECF   46,F
016B:  DECF   45,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
016C:  MOVF   45,W
016D:  MOVWF  04
016E:  MOVF   46,W
016F:  MOVWF  05
0170:  MOVF   3C,W
0171:  MOVWF  20
0172:  SWAPF  20,F
0173:  RLF    20,F
0174:  MOVLW  E0
0175:  ANDWF  20,F
0176:  MOVF   20,W
0177:  ANDLW  E0
0178:  MOVWF  00
....................  
....................       //sidh 
....................       ptr--; 
0179:  MOVF   45,W
017A:  BTFSC  03.2
017B:  DECF   46,F
017C:  DECF   45,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
017D:  MOVF   45,W
017E:  MOVWF  04
017F:  MOVF   46,W
0180:  MOVWF  05
0181:  MOVF   3C,W
0182:  MOVWF  20
0183:  RRF    20,F
0184:  RRF    20,F
0185:  RRF    20,F
0186:  MOVLW  1F
0187:  ANDWF  20,F
0188:  MOVF   20,W
0189:  ANDLW  1F
018A:  MOVWF  00
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
018B:  MOVF   45,W
018C:  MOVWF  04
018D:  MOVF   46,W
018E:  MOVWF  05
018F:  MOVF   3D,W
0190:  MOVWF  20
0191:  SWAPF  20,F
0192:  RLF    20,F
0193:  MOVLW  E0
0194:  ANDWF  20,F
0195:  MOVF   20,W
0196:  ANDLW  E0
0197:  IORWF  00,W
0198:  MOVWF  00
....................    } 
....................  
....................    //0=eidl, 1=eidh, 2=sidl, 3=sidh 
....................    mcp2510_write(addr--, converted_id[3]); 
0199:  MOVF   3B,W
019A:  DECF   3B,F
019B:  MOVWF  47
019C:  MOVWF  66
019D:  MOVF   44,W
019E:  MOVWF  67
019F:  CALL   0AB
....................    mcp2510_write(addr--, converted_id[2]); 
01A0:  MOVF   3B,W
01A1:  DECF   3B,F
01A2:  MOVWF  47
01A3:  MOVWF  66
01A4:  MOVF   43,W
01A5:  MOVWF  67
01A6:  CALL   0AB
....................    mcp2510_write(addr--, converted_id[1]); 
01A7:  MOVF   3B,W
01A8:  DECF   3B,F
01A9:  MOVWF  47
01AA:  MOVWF  66
01AB:  MOVF   42,W
01AC:  MOVWF  67
01AD:  CALL   0AB
....................    mcp2510_write(addr, converted_id[0]); 
01AE:  MOVF   3B,W
01AF:  MOVWF  66
01B0:  MOVF   41,W
01B1:  MOVWF  67
01B2:  CALL   0AB
01B3:  RETURN
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int8 addr, int1 ext) 
.................... { 
....................    unsigned int32 ret; 
....................    unsigned int8 * ptr; 
....................    unsigned int8 converted_id[4]; 
....................  
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh 
*
0381:  MOVLW  20
0382:  MOVWF  6F
0383:  MOVLW  53
0384:  MOVWF  6E
....................  
....................    converted_id[3]=mcp2510_read(addr--); 
0385:  MOVF   68,W
0386:  DECF   68,F
0387:  MOVLB  01
0388:  MOVWF  24
0389:  MOVWF  25
038A:  MOVLB  00
038B:  CALL   080
038C:  MOVF   21,W
038D:  MOVLB  01
038E:  MOVWF  23
....................    converted_id[2]=mcp2510_read(addr--); 
038F:  MOVLB  00
0390:  MOVF   68,W
0391:  DECF   68,F
0392:  MOVLB  01
0393:  MOVWF  24
0394:  MOVWF  25
0395:  MOVLB  00
0396:  CALL   080
0397:  MOVF   21,W
0398:  MOVLB  01
0399:  MOVWF  22
....................    converted_id[1]=mcp2510_read(addr--); 
039A:  MOVLB  00
039B:  MOVF   68,W
039C:  DECF   68,F
039D:  MOVLB  01
039E:  MOVWF  24
039F:  MOVWF  25
03A0:  MOVLB  00
03A1:  CALL   080
03A2:  MOVF   21,W
03A3:  MOVLB  01
03A4:  MOVWF  21
....................    converted_id[0]=mcp2510_read(addr); 
03A5:  MOVLB  00
03A6:  MOVF   68,W
03A7:  MOVLB  01
03A8:  MOVWF  25
03A9:  MOVLB  00
03AA:  CALL   080
03AB:  MOVF   21,W
03AC:  MOVLB  01
03AD:  MOVWF  20
....................  
....................    ret=0; 
03AE:  MOVLB  00
03AF:  CLRF   6D
03B0:  CLRF   6C
03B1:  CLRF   6B
03B2:  CLRF   6A
....................  
....................  
....................    if (ext) 
03B3:  MOVF   69,F
03B4:  BTFSC  03.2
03B5:  GOTO   464
....................    { 
....................       ret=(unsigned int32)*ptr;  //eidl 
03B6:  MOVF   6E,W
03B7:  MOVWF  04
03B8:  MOVF   6F,W
03B9:  MOVWF  05
03BA:  MOVF   00,W
03BB:  CLRF   6D
03BC:  CLRF   6C
03BD:  CLRF   6B
03BE:  MOVWF  6A
....................  
....................       ptr--;     //eidh 
03BF:  MOVF   6E,W
03C0:  BTFSC  03.2
03C1:  DECF   6F,F
03C2:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 8); 
03C3:  MOVF   6E,W
03C4:  MOVWF  04
03C5:  MOVF   6F,W
03C6:  MOVWF  05
03C7:  MOVF   00,W
03C8:  MOVLB  01
03C9:  CLRF   27
03CA:  CLRF   26
03CB:  CLRF   25
03CC:  MOVWF  24
03CD:  MOVF   26,W
03CE:  MOVLB  00
03CF:  MOVWF  23
03D0:  MOVLB  01
03D1:  MOVF   25,W
03D2:  MOVLB  00
03D3:  MOVWF  22
03D4:  MOVLB  01
03D5:  MOVF   24,W
03D6:  MOVLB  00
03D7:  MOVWF  21
03D8:  CLRF   20
03D9:  MOVF   20,W
03DA:  IORWF  6A,F
03DB:  MOVF   21,W
03DC:  IORWF  6B,F
03DD:  MOVF   22,W
03DE:  IORWF  6C,F
03DF:  MOVF   23,W
03E0:  IORWF  6D,F
....................  
....................       ptr--;     //sidl 
03E1:  MOVF   6E,W
03E2:  BTFSC  03.2
03E3:  DECF   6F,F
03E4:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
03E5:  MOVF   6E,W
03E6:  MOVWF  04
03E7:  MOVF   6F,W
03E8:  MOVWF  05
03E9:  MOVF   00,W
03EA:  MOVLB  01
03EB:  CLRF   27
03EC:  CLRF   26
03ED:  CLRF   25
03EE:  MOVWF  24
03EF:  MOVLW  03
03F0:  ANDWF  24,F
03F1:  CLRF   25
03F2:  CLRF   26
03F3:  CLRF   27
03F4:  MOVF   25,W
03F5:  MOVLB  00
03F6:  MOVWF  23
03F7:  MOVLB  01
03F8:  MOVF   24,W
03F9:  MOVLB  00
03FA:  MOVWF  22
03FB:  CLRF   20
03FC:  CLRF   21
03FD:  MOVF   20,W
03FE:  IORWF  6A,F
03FF:  MOVF   21,W
0400:  IORWF  6B,F
0401:  MOVF   22,W
0402:  IORWF  6C,F
0403:  MOVF   23,W
0404:  IORWF  6D,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
0405:  MOVF   6E,W
0406:  MOVWF  04
0407:  MOVF   6F,W
0408:  MOVWF  05
0409:  MOVF   00,W
040A:  MOVLB  01
040B:  CLRF   27
040C:  CLRF   26
040D:  CLRF   25
040E:  MOVWF  24
040F:  MOVLW  E0
0410:  ANDWF  24,F
0411:  CLRF   25
0412:  CLRF   26
0413:  CLRF   27
0414:  MOVLB  00
0415:  CLRF   20
0416:  MOVLB  01
0417:  RLF    24,W
0418:  MOVLB  00
0419:  MOVWF  21
041A:  MOVLB  01
041B:  RLF    25,W
041C:  MOVLB  00
041D:  MOVWF  22
041E:  MOVLB  01
041F:  RLF    26,W
0420:  MOVLB  00
0421:  MOVWF  23
0422:  RLF    21,F
0423:  RLF    22,F
0424:  RLF    23,F
0425:  RLF    21,F
0426:  RLF    22,F
0427:  RLF    23,F
0428:  RLF    21,F
0429:  RLF    22,F
042A:  RLF    23,F
042B:  RLF    21,F
042C:  RLF    22,F
042D:  RLF    23,F
042E:  MOVLW  E0
042F:  ANDWF  21,F
0430:  MOVF   20,W
0431:  IORWF  6A,F
0432:  MOVF   21,W
0433:  IORWF  6B,F
0434:  MOVF   22,W
0435:  IORWF  6C,F
0436:  MOVF   23,W
0437:  IORWF  6D,F
....................  
....................       ptr--;     //sidh 
0438:  MOVF   6E,W
0439:  BTFSC  03.2
043A:  DECF   6F,F
043B:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 21); 
043C:  MOVF   6E,W
043D:  MOVWF  04
043E:  MOVF   6F,W
043F:  MOVWF  05
0440:  MOVF   00,W
0441:  MOVLB  01
0442:  CLRF   27
0443:  CLRF   26
0444:  CLRF   25
0445:  MOVWF  24
0446:  MOVLB  00
0447:  CLRF   20
0448:  CLRF   21
0449:  MOVLB  01
044A:  RLF    24,W
044B:  MOVLB  00
044C:  MOVWF  22
044D:  MOVLB  01
044E:  RLF    25,W
044F:  MOVLB  00
0450:  MOVWF  23
0451:  RLF    22,F
0452:  RLF    23,F
0453:  RLF    22,F
0454:  RLF    23,F
0455:  RLF    22,F
0456:  RLF    23,F
0457:  RLF    22,F
0458:  RLF    23,F
0459:  MOVLW  E0
045A:  ANDWF  22,F
045B:  MOVF   20,W
045C:  IORWF  6A,F
045D:  MOVF   21,W
045E:  IORWF  6B,F
045F:  MOVF   22,W
0460:  IORWF  6C,F
0461:  MOVF   23,W
0462:  IORWF  6D,F
....................    } 
0463:  GOTO   4C7
....................    else 
....................    { 
....................       ptr-=2;    //sidl 
0464:  MOVLW  02
0465:  SUBWF  6E,F
0466:  MOVLW  00
0467:  SUBWFC 6F,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
0468:  MOVF   6E,W
0469:  MOVWF  04
046A:  MOVF   6F,W
046B:  MOVWF  05
046C:  MOVF   00,W
046D:  MOVLB  01
046E:  CLRF   27
046F:  CLRF   26
0470:  CLRF   25
0471:  MOVWF  24
0472:  MOVLW  E0
0473:  ANDWF  24,F
0474:  CLRF   25
0475:  CLRF   26
0476:  CLRF   27
0477:  RRF    27,W
0478:  MOVLB  00
0479:  MOVWF  6D
047A:  MOVLB  01
047B:  RRF    26,W
047C:  MOVLB  00
047D:  MOVWF  6C
047E:  MOVLB  01
047F:  RRF    25,W
0480:  MOVLB  00
0481:  MOVWF  6B
0482:  MOVLB  01
0483:  RRF    24,W
0484:  MOVLB  00
0485:  MOVWF  6A
0486:  RRF    6D,F
0487:  RRF    6C,F
0488:  RRF    6B,F
0489:  RRF    6A,F
048A:  RRF    6D,F
048B:  RRF    6C,F
048C:  RRF    6B,F
048D:  RRF    6A,F
048E:  RRF    6D,F
048F:  RRF    6C,F
0490:  RRF    6B,F
0491:  RRF    6A,F
0492:  RRF    6D,F
0493:  RRF    6C,F
0494:  RRF    6B,F
0495:  RRF    6A,F
0496:  MOVLW  07
0497:  ANDWF  6D,F
....................  
....................       ptr--;     //sidh 
0498:  MOVF   6E,W
0499:  BTFSC  03.2
049A:  DECF   6F,F
049B:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 3); 
049C:  MOVF   6E,W
049D:  MOVWF  04
049E:  MOVF   6F,W
049F:  MOVWF  05
04A0:  MOVF   00,W
04A1:  MOVLB  01
04A2:  CLRF   27
04A3:  CLRF   26
04A4:  CLRF   25
04A5:  MOVWF  24
04A6:  RLF    24,W
04A7:  MOVLB  00
04A8:  MOVWF  20
04A9:  MOVLB  01
04AA:  RLF    25,W
04AB:  MOVLB  00
04AC:  MOVWF  21
04AD:  MOVLB  01
04AE:  RLF    26,W
04AF:  MOVLB  00
04B0:  MOVWF  22
04B1:  MOVLB  01
04B2:  RLF    27,W
04B3:  MOVLB  00
04B4:  MOVWF  23
04B5:  RLF    20,F
04B6:  RLF    21,F
04B7:  RLF    22,F
04B8:  RLF    23,F
04B9:  RLF    20,F
04BA:  RLF    21,F
04BB:  RLF    22,F
04BC:  RLF    23,F
04BD:  MOVLW  F8
04BE:  ANDWF  20,F
04BF:  MOVF   20,W
04C0:  IORWF  6A,F
04C1:  MOVF   21,W
04C2:  IORWF  6B,F
04C3:  MOVF   22,W
04C4:  IORWF  6C,F
04C5:  MOVF   23,W
04C6:  IORWF  6D,F
....................    } 
....................  
....................    return(ret); 
04C7:  MOVF   6A,W
04C8:  MOVWF  20
04C9:  MOVF   6B,W
04CA:  MOVWF  21
04CB:  MOVF   6C,W
04CC:  MOVWF  22
04CD:  MOVF   6D,W
04CE:  MOVWF  23
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int8 * data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 port; 
....................  
....................    unsigned int8 TXRXBaD0; 
....................    unsigned int8 TXBaCTRL; 
....................    unsigned int8 TXRXBaEIDL; 
....................    unsigned int8 TXBaDLC; 
....................  
....................    struct txbNctrl_struct b_TXBaCTRL; 
....................    struct rxbNdlc_struct b_TXBaDLC; 
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL; 
....................  
....................    //b_TXB0CTRL=mcp2510_read(TXB0CTRL); 
....................    memset(&b_TXB0CTRL,mcp2510_read(TXB0CTRL),1); 
....................    //b_TXB1CTRL=mcp2510_read(TXB1CTRL); 
....................    memset(&b_TXB1CTRL,mcp2510_read(TXB1CTRL),1); 
....................    //b_TXB2CTRL=mcp2510_read(TXB2CTRL); 
....................    memset(&b_TXB2CTRL,mcp2510_read(TXB2CTRL),1); 
....................     
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!b_TXB0CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB0D0; 
....................       TXBaCTRL=TXB0CTRL; 
....................       TXRXBaEIDL=TXB0EIDL; 
....................       TXBaDLC=TXB0DLC; 
....................       port=0; 
....................    } 
....................    else if (!b_TXB1CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB1D0; 
....................       TXBaCTRL=TXB1CTRL; 
....................       TXRXBaEIDL=TXB1EIDL; 
....................       TXBaDLC=TXB1DLC; 
....................       port=1; 
....................    } 
....................    else if (!b_TXB2CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB2D0; 
....................       TXBaCTRL=TXB2CTRL; 
....................       TXRXBaEIDL=TXB2EIDL; 
....................       TXBaDLC=TXB2DLC; 
....................       port=2; 
....................    } 
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
....................    } 
....................     
....................     
....................     
....................    //set priority. 
....................    //b_TXBaCTRL=mcp2510_read(TXBaCTRL); 
....................    memset(&b_TXBaCTRL,mcp2510_read(TXBaCTRL),1); 
....................     
....................    b_TXBaCTRL.txpri=priority; 
....................    mcp2510_write(TXBaCTRL, (unsigned int8)b_TXBaCTRL); 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaEIDL, id, ext); 
....................  
....................    //set tx data count 
....................    //b_TXBaDLC=len; 
....................    memset(&b_TXBaDLC,len,1); 
....................    b_TXBaDLC.rtr=rtr; 
....................    mcp2510_write(TXBaDLC, (unsigned int8)b_TXBaDLC); 
....................  
....................    //write to buffer 
....................     for (i=TXRXBaD0; i<(TXRXBaD0 + len); i++) 
....................     { 
....................       mcp2510_write(i,*data); 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    //b_TXBaCTRL=mcp2510_read(TXBaCTRL); 
....................    memset(&b_TXBaCTRL,mcp2510_read(TXBaCTRL),1); 
....................    b_TXBaCTRL.txreq=1; 
....................    mcp2510_write(TXBaCTRL, (unsigned int8)b_TXBaCTRL); 
....................     
....................     
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) 
....................             { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) 
....................                { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int8 * data, unsigned int8 & len, struct rx_stat & stat) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    struct struct_RXB0CTRL b_RXB0CTRL; 
....................    struct struct_RXB1CTRL b_RXB1CTRL; 
....................    struct struct_EFLG b_EFLG; 
....................  
....................    unsigned int8 RXBaDLC; 
....................    struct rxbNdlc_struct b_RXBaDLC; 
....................  
....................    unsigned int8 TXRXBaSIDL; 
....................    struct struct_TXRXBaSIDL b_TXRXBaSIDL; 
....................  
....................  
....................    unsigned int8 RXBaD0; 
....................    struct struct_CANINTF b_CANINTF; 
....................  
....................    //b_CANINTF=mcp2510_read(CANINTF); 
....................    memset(&b_CANINTF,mcp2510_read(CANINTF),1); 
*
02CF:  MOVLW  2C
02D0:  MOVLB  01
02D1:  MOVWF  25
02D2:  MOVLB  00
02D3:  CALL   080
02D4:  MOVF   21,W
02D5:  MOVWF  60
02D6:  MOVLW  20
02D7:  MOVWF  05
02D8:  MOVLW  3F
02D9:  MOVWF  04
02DA:  MOVF   21,W
02DB:  MOVWF  20
02DC:  MOVLW  01
02DD:  MOVWF  21
02DE:  CALL   0A3
....................    //b_RXB0CTRL=mcp2510_read(RXB0CTRL); 
....................    memset(&b_RXB0CTRL,mcp2510_read(RXB0CTRL),1); 
02DF:  MOVLW  60
02E0:  MOVLB  01
02E1:  MOVWF  25
02E2:  MOVLB  00
02E3:  CALL   080
02E4:  MOVF   21,W
02E5:  MOVWF  60
02E6:  MOVLW  20
02E7:  MOVWF  05
02E8:  MOVLW  37
02E9:  MOVWF  04
02EA:  MOVF   21,W
02EB:  MOVWF  20
02EC:  MOVLW  01
02ED:  MOVWF  21
02EE:  CALL   0A3
....................    //b_RXB1CTRL=mcp2510_read(RXB1CTRL); 
....................    memset(&b_RXB1CTRL,mcp2510_read(RXB1CTRL),1); 
02EF:  MOVLW  70
02F0:  MOVLB  01
02F1:  MOVWF  25
02F2:  MOVLB  00
02F3:  CALL   080
02F4:  MOVF   21,W
02F5:  MOVWF  60
02F6:  MOVLW  20
02F7:  MOVWF  05
02F8:  MOVLW  38
02F9:  MOVWF  04
02FA:  MOVF   21,W
02FB:  MOVWF  20
02FC:  MOVLW  01
02FD:  MOVWF  21
02FE:  CALL   0A3
....................    //b_EFLG=mcp2510_read(EFLG); 
....................    memset(&b_EFLG,mcp2510_read(EFLG),1); 
02FF:  MOVLW  2D
0300:  MOVLB  01
0301:  MOVWF  25
0302:  MOVLB  00
0303:  CALL   080
0304:  MOVF   21,W
0305:  MOVWF  60
0306:  MOVLW  20
0307:  MOVWF  05
0308:  MOVLW  39
0309:  MOVWF  04
030A:  MOVF   21,W
030B:  MOVWF  20
030C:  MOVLW  01
030D:  MOVWF  21
030E:  CALL   0A3
....................  
....................     if (b_CANINTF.rx0if) 
030F:  BTFSS  5F.0
0310:  GOTO   32E
....................     { 
....................         stat.buffer=0; 
0311:  BCF    3A.4
....................  
....................         stat.err_ovfl=b_EFLG.rx0ovr; 
0312:  BCF    3A.0
0313:  BTFSC  59.6
0314:  BSF    3A.0
....................         b_EFLG.rx0ovr=0; 
0315:  BCF    59.6
....................         mcp2510_write(EFLG, (unsigned int8)b_EFLG); 
0316:  MOVLW  2D
0317:  MOVWF  66
0318:  MOVF   59,W
0319:  MOVWF  67
031A:  CALL   0AB
....................  
....................         if (b_RXB0CTRL.bukt) 
031B:  BTFSS  57.2
031C:  GOTO   327
....................         { 
....................          stat.filthit=b_RXB0CTRL.filhit0; 
031D:  MOVLW  00
031E:  BTFSC  57.0
031F:  MOVLW  01
0320:  ANDLW  07
0321:  MOVWF  20
0322:  LSLF   20,F
0323:  MOVLW  F1
0324:  ANDWF  3A,W
0325:  IORWF  20,W
0326:  MOVWF  3A
....................         } 
....................  
....................         RXBaDLC=RXB0DLC; 
0327:  MOVLW  65
0328:  MOVWF  5A
....................         TXRXBaSIDL=RXB0SIDL; 
0329:  MOVLW  62
032A:  MOVWF  5C
....................         RXBaD0=RXB0D0; 
032B:  MOVLW  66
032C:  MOVWF  5E
....................     } 
032D:  GOTO   34D
....................     else if (b_CANINTF.rx1if) 
032E:  BTFSS  5F.1
032F:  GOTO   34A
....................     { 
....................         stat.buffer=1; 
0330:  BSF    3A.4
....................  
....................         stat.err_ovfl=b_EFLG.rx1ovr; 
0331:  BCF    3A.0
0332:  BTFSC  59.7
0333:  BSF    3A.0
....................         b_EFLG.rx1ovr=0; 
0334:  BCF    59.7
....................         mcp2510_write(EFLG, (unsigned int8)b_EFLG); 
0335:  MOVLW  2D
0336:  MOVWF  66
0337:  MOVF   59,W
0338:  MOVWF  67
0339:  CALL   0AB
....................  
....................         stat.filthit=b_RXB1CTRL.filhit0; 
033A:  MOVF   58,W
033B:  ANDLW  07
033C:  ANDLW  07
033D:  MOVWF  20
033E:  LSLF   20,F
033F:  MOVLW  F1
0340:  ANDWF  3A,W
0341:  IORWF  20,W
0342:  MOVWF  3A
....................         RXBaDLC=RXB1DLC; 
0343:  MOVLW  75
0344:  MOVWF  5A
....................         TXRXBaSIDL=RXB1SIDL; 
0345:  MOVLW  72
0346:  MOVWF  5C
....................         RXBaD0=RXB1D0; 
0347:  MOVLW  76
0348:  MOVWF  5E
....................     } 
0349:  GOTO   34D
....................     else 
....................     { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
034A:  MOVLW  00
034B:  MOVWF  21
034C:  GOTO   505
....................     } 
....................  
....................    //get count 
....................     //b_RXBaDLC=mcp2510_read(RXBaDLC); 
....................     memset(&b_RXBaDLC,mcp2510_read(RXBaDLC),1); 
034D:  MOVF   5A,W
034E:  MOVLB  01
034F:  MOVWF  25
0350:  MOVLB  00
0351:  CALL   080
0352:  MOVF   21,W
0353:  MOVWF  60
0354:  MOVLW  20
0355:  MOVWF  05
0356:  MOVLW  3B
0357:  MOVWF  04
0358:  MOVF   21,W
0359:  MOVWF  20
035A:  MOVLW  01
035B:  MOVWF  21
035C:  CALL   0A3
....................     len = b_RXBaDLC.dlc; 
035D:  MOVF   5B,W
035E:  ANDLW  0F
035F:  MOVWF  3F
....................     stat.rtr=b_RXBaDLC.rtr; 
0360:  BCF    3A.5
0361:  BTFSC  5B.6
0362:  BSF    3A.5
....................  
....................    //was it extended or standard? 
....................     //b_TXRXBaSIDL=mcp2510_read(TXRXBaSIDL); 
....................     memset(&b_TXRXBaSIDL,mcp2510_read(TXRXBaSIDL),1); 
0363:  MOVF   5C,W
0364:  MOVLB  01
0365:  MOVWF  25
0366:  MOVLB  00
0367:  CALL   080
0368:  MOVF   21,W
0369:  MOVWF  60
036A:  MOVLW  20
036B:  MOVWF  05
036C:  MOVLW  3D
036D:  MOVWF  04
036E:  MOVF   21,W
036F:  MOVWF  20
0370:  MOVLW  01
0371:  MOVWF  21
0372:  CALL   0A3
....................     stat.ext=b_TXRXBaSIDL.ext; 
0373:  BCF    3A.6
0374:  BTFSC  5D.3
0375:  BSF    3A.6
....................     id=can_get_id(TXRXBaSIDL + 2,stat.ext); 
0376:  MOVLW  02
0377:  ADDWF  5C,W
0378:  MOVWF  60
0379:  MOVLW  00
037A:  BTFSC  3A.6
037B:  MOVLW  01
037C:  MOVWF  61
037D:  MOVF   60,W
037E:  MOVWF  68
037F:  MOVF   61,W
0380:  MOVWF  69
*
04CF:  MOVF   23,W
04D0:  MOVWF  43
04D1:  MOVF   22,W
04D2:  MOVWF  42
04D3:  MOVF   21,W
04D4:  MOVWF  41
04D5:  MOVF   20,W
04D6:  MOVWF  40
....................  
....................    //get data 
....................     for ( i = RXBaD0; i < (RXBaD0 + len); i++ ) 
04D7:  MOVF   5E,W
04D8:  MOVWF  56
04D9:  MOVF   3F,W
04DA:  ADDWF  5E,W
04DB:  SUBWF  56,W
04DC:  BTFSC  03.0
04DD:  GOTO   4F4
....................     { 
....................         *data=mcp2510_read(i); 
04DE:  MOVF   55,W
04DF:  MOVWF  23
04E0:  MOVF   54,W
04E1:  MOVWF  60
04E2:  MOVF   55,W
04E3:  MOVWF  61
04E4:  MOVF   56,W
04E5:  MOVLB  01
04E6:  MOVWF  25
04E7:  MOVLB  00
04E8:  CALL   080
04E9:  MOVF   61,W
04EA:  MOVWF  05
04EB:  MOVF   60,W
04EC:  MOVWF  04
04ED:  MOVF   21,W
04EE:  MOVWF  00
....................         data++; 
04EF:  INCF   54,F
04F0:  BTFSC  03.2
04F1:  INCF   55,F
04F2:  INCF   56,F
04F3:  GOTO   4D9
....................     } 
....................  
....................     stat.inv=b_CANINTF.merrf; 
04F4:  BCF    3A.7
04F5:  BTFSC  5F.7
04F6:  BSF    3A.7
....................     if (b_CANINTF.merrf) 
04F7:  BTFSC  5F.7
....................     { 
....................        b_CANINTF.merrf=0; 
04F8:  BCF    5F.7
....................     } 
....................      
....................     if (stat.buffer) 
04F9:  BTFSS  3A.4
04FA:  GOTO   4FD
....................     { 
....................        b_CANINTF.rx1if=0; 
04FB:  BCF    5F.1
....................     } 
04FC:  GOTO   4FE
....................     else 
....................     { 
....................        b_CANINTF.rx0if=0; 
04FD:  BCF    5F.0
....................     } 
....................      
....................     mcp2510_write(CANINTF, (unsigned int8)b_CANINTF); 
04FE:  MOVLW  2C
04FF:  MOVWF  66
0500:  MOVF   5F,W
0501:  MOVWF  67
0502:  CALL   0AB
....................  
....................     #if CAN_DO_DEBUG 
....................         
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr))  
....................        { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++)  
....................           { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
0503:  MOVLW  01
0504:  MOVWF  21
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_kbhit() 
.................... // 
.................... // Returns TRUE if there is data in the receive buffers 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_kbhit(void) 
.................... { 
....................    struct struct_CANINTF b_CANINTF; 
....................  
....................    //b_CANINTF=mcp2510_read(CANINTF); 
....................    memset(&b_CANINTF,mcp2510_read(CANINTF),1); 
....................    if (b_CANINTF.rx0if || b_CANINTF.rx1if) 
....................    { 
....................       return(1); 
....................    } 
....................  
....................    return(0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_tbe() 
.................... // 
.................... // Returns TRUE if the transmit buffers are empty and ready to transmit data 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_tbe(void) 
.................... { 
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL; 
....................  
....................    //b_TXB0CTRL=mcp2510_read(TXB0CTRL); 
....................    memset(&b_TXB0CTRL,mcp2510_read(TXB0CTRL),1); 
....................    //b_TXB1CTRL=mcp2510_read(TXB1CTRL); 
....................    memset(&b_TXB1CTRL,mcp2510_read(TXB1CTRL),1); 
....................    //b_TXB2CTRL=mcp2510_read(TXB2CTRL); 
....................    memset(&b_TXB2CTRL,mcp2510_read(TXB2CTRL),1); 
....................  
....................    if (!b_TXB0CTRL.txreq || !b_TXB1CTRL.txreq || !b_TXB2CTRL.txreq) 
....................    { 
....................       return(1); 
....................    } 
....................  
....................    return(0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_abort() 
.................... // 
.................... // Aborts all pending tranmissions. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_abort(void) 
.................... { 
....................    struct struct_CANCTRL b_CANCTRL; 
....................  
....................    //b_CANCTRL=mcp2510_read(CANCTRL); 
....................    memset(&b_CANCTRL,mcp2510_read(CANCTRL),1); 
....................    b_CANCTRL.abat=1; 
....................    mcp2510_write(CANCTRL, (unsigned int8)b_CANCTRL); 
....................  
....................    delay_ms(5); 
....................    b_CANCTRL.abat=0; 
....................    mcp2510_write(CANCTRL, (unsigned int8)b_CANCTRL); 
.................... } 
....................  
.................... void can_set_interr(int8 interr) 
.................... { 
....................    ///////ADICIONADO: FERNANDO 
....................    mcp2510_write(CANINTE,interr); 
*
026B:  MOVLW  2B
026C:  MOVWF  66
026D:  MOVF   3A,W
026E:  MOVWF  67
026F:  CALL   0AB
0270:  MOVLP  00
0271:  GOTO   61D (RETURN)
.................... } 
....................  
....................  
.................... /////////////////// 
.................... /// 
.................... // 
.................... // SPI CODE 
.................... // 
.................... /// 
.................... ////////////////// 
.................... //! 
....................  
.................... #ifndef USE_HARDWARE_SPI 
....................    #use spi(MASTER,MODE=0,DI=EXT_CAN_SI,DO=EXT_CAN_SO,CLK=EXT_CAN_SCK,bits=8,stream=MCP2510) 
*
0055:  MOVLB  01
0056:  MOVF   28,W
0057:  SUBLW  08
0058:  BTFSC  03.2
0059:  GOTO   05E
005A:  MOVWF  29
005B:  RLF    27,F
005C:  DECFSZ 29,F
005D:  GOTO   05B
005E:  BSF    0E.1
005F:  BCF    0E.2
0060:  BCF    0E.0
0061:  MOVLB  02
0062:  BCF    0E.0
0063:  MOVLB  01
0064:  MOVF   28,W
0065:  MOVWF  29
0066:  BTFSC  27.7
0067:  GOTO   06B
0068:  MOVLB  02
0069:  BCF    0E.2
006A:  MOVLB  01
006B:  BTFSS  27.7
006C:  GOTO   070
006D:  MOVLB  02
006E:  BSF    0E.2
006F:  MOVLB  01
0070:  RLF    27,F
0071:  MOVLB  02
0072:  BSF    0E.0
0073:  MOVLB  00
0074:  RLF    21,F
0075:  BTFSS  0E.1
0076:  BCF    21.0
0077:  BTFSC  0E.1
0078:  BSF    21.0
0079:  MOVLB  02
007A:  BCF    0E.0
007B:  MOVLB  01
007C:  DECFSZ 29,F
007D:  GOTO   066
007E:  MOVLB  00
007F:  RETURN
.................... #else 
....................    //#USE SPI (MASTER, SPI1, MODE=0, BITS=8, STREAM=MCP2510) 
....................    #use spi(MASTER,MODE=0,DI=EXT_CAN_SI,DO=EXT_CAN_SO,CLK=EXT_CAN_SCK,bits=8,stream=MCP2510,FORCE_HW) 
.................... #endif 
.................... //! 
....................  
.................... //data clocked in on rising edge 
.................... //data driven out on falling edge 
.................... unsigned int8 mcp2510_read(unsigned int8 address) 
.................... { 
....................    unsigned int8 data; 
....................  
....................    output_low(EXT_CAN_CS); 
0080:  MOVLB  01
0081:  BCF    0E.3
0082:  MOVLB  02
0083:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,0x03); 
0084:  MOVLW  03
0085:  MOVLB  01
0086:  MOVWF  27
0087:  MOVLW  08
0088:  MOVWF  28
0089:  MOVLB  00
008A:  CALL   055
....................    spi_xfer(MCP2510,address); 
008B:  MOVLB  01
008C:  MOVF   25,W
008D:  MOVWF  27
008E:  MOVLW  08
008F:  MOVWF  28
0090:  MOVLB  00
0091:  CALL   055
....................    data =spi_xfer(MCP2510,0); 
0092:  MOVLB  01
0093:  CLRF   27
0094:  MOVLW  08
0095:  MOVWF  28
0096:  MOVLB  00
0097:  CALL   055
0098:  MOVF   21,W
0099:  MOVLB  01
009A:  MOVWF  26
....................     
....................    output_high(EXT_CAN_CS); 
009B:  BCF    0E.3
009C:  MOVLB  02
009D:  BSF    0E.3
....................  
....................    return(data); 
009E:  MOVLB  01
009F:  MOVF   26,W
00A0:  MOVLB  00
00A1:  MOVWF  21
00A2:  RETURN
.................... } 
....................  
.................... unsigned int8 mcp2510_status(void) 
.................... { 
....................    unsigned int8 data; 
....................     
....................    output_low(EXT_CAN_CS); 
....................     
....................    spi_xfer(MCP2510,0xA0); 
....................    data = spi_xfer(MCP2510,0); 
....................    spi_xfer(MCP2510,0); 
....................     
....................    output_high(EXT_CAN_CS); 
....................  
....................    return(data); 
.................... } 
....................  
....................  
.................... void mcp2510_write(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    output_low(EXT_CAN_CS); 
*
00AB:  MOVLB  01
00AC:  BCF    0E.3
00AD:  MOVLB  02
00AE:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,0x02); 
00AF:  MOVLW  02
00B0:  MOVLB  01
00B1:  MOVWF  27
00B2:  MOVLW  08
00B3:  MOVWF  28
00B4:  MOVLB  00
00B5:  CALL   055
....................    spi_xfer(MCP2510,address); 
00B6:  MOVF   66,W
00B7:  MOVLB  01
00B8:  MOVWF  27
00B9:  MOVLW  08
00BA:  MOVWF  28
00BB:  MOVLB  00
00BC:  CALL   055
....................    spi_xfer(MCP2510,data); 
00BD:  MOVF   67,W
00BE:  MOVLB  01
00BF:  MOVWF  27
00C0:  MOVLW  08
00C1:  MOVWF  28
00C2:  MOVLB  00
00C3:  CALL   055
....................     
....................    output_high(EXT_CAN_CS); 
00C4:  MOVLB  01
00C5:  BCF    0E.3
00C6:  MOVLB  02
00C7:  BSF    0E.3
00C8:  MOVLB  00
00C9:  RETURN
.................... } 
....................  
.................... void mcp2510_command(unsigned int8 command) 
.................... { 
....................    output_low(EXT_CAN_CS); 
*
01C5:  MOVLB  01
01C6:  BCF    0E.3
01C7:  MOVLB  02
01C8:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,command); 
01C9:  MOVLB  00
01CA:  MOVF   3B,W
01CB:  MOVLB  01
01CC:  MOVWF  27
01CD:  MOVLW  08
01CE:  MOVWF  28
01CF:  MOVLB  00
01D0:  CALL   055
....................     
....................    output_high(EXT_CAN_CS); 
01D1:  MOVLB  01
01D2:  BCF    0E.3
01D3:  MOVLB  02
01D4:  BSF    0E.3
.................... } 
....................  
.................... void mcp2510_bitmodify(unsigned int8 address, unsigned int8 mask, unsigned int8 data) 
.................... { 
....................    output_low(EXT_CAN_CS); 
....................     
....................    spi_xfer(MCP2510,0x05); 
....................    spi_xfer(MCP2510,address); 
....................    spi_xfer(MCP2510,mask); 
....................    spi_xfer(MCP2510,data); 
....................     
....................    output_high(EXT_CAN_CS); 
.................... } 
....................  
....................  
.................... void mcp2510_init(void) 
.................... { 
....................    output_high(EXT_CAN_CS); 
*
01B4:  MOVLB  01
01B5:  BCF    0E.3
01B6:  MOVLB  02
01B7:  BSF    0E.3
....................    output_low(EXT_CAN_SI); 
01B8:  MOVLB  01
01B9:  BCF    0E.1
01BA:  MOVLB  02
01BB:  BCF    0E.1
....................    output_low(EXT_CAN_SCK); 
01BC:  MOVLB  01
01BD:  BCF    0E.0
01BE:  MOVLB  02
01BF:  BCF    0E.0
....................    output_float(EXT_CAN_SO); 
01C0:  MOVLB  01
01C1:  BSF    0E.2
....................  
....................    #ifdef EXT_CAN_TX0RTS 
....................     output_high(EXT_CAN_TX0RTS); 
....................    #endif 
....................    #ifdef EXT_CAN_TX1RTS 
....................     output_high(EXT_CAN_TX1RTS); 
....................    #endif 
....................    #ifdef EXT_CAN_TX2RTS 
....................     output_high(EXT_CAN_TX2RTS); 
....................    #endif 
....................  
....................   #ifdef EXT_CAN_TX0RTS 
....................    output_high(EXT_CAN_RESET); 
....................    output_low(EXT_CAN_RESET); 
....................    output_high(EXT_CAN_RESET); 
....................    delay_ms(20); 
....................   #endif 
....................    
....................    mcp2510_command(0xC0);   //reset 
01C2:  MOVLW  C0
01C3:  MOVLB  00
01C4:  MOVWF  3B
....................     
....................    delay_ms(20); 
*
01D5:  MOVLW  14
01D6:  MOVLB  00
01D7:  MOVWF  40
01D8:  CALL   040
.................... } 
....................  
....................  
.................... //void can_debug(int) 
....................  
.................... #include <placa_plus.h> 
.................... //******************************** 
.................... //*   EEPROM                     * 
.................... //******************************** 
.................... //DEFINE EEPROM_NOME PRIMEIRO ENDERECO,TAMANHO BYTES 
....................  
.................... //conta transmissões perdidas na CAN - bytes 0 a 3 
.................... #ROM 0xF000 = {0x00,0x00,0x00,0x00} 
.................... #DEFINE EP_NAO_TRANS 0x00,0x04 
....................  
.................... //conta quantas horas ligado desde o ultimo reset - bytes 4 a 5 
.................... #ROM 0xF004 = {0x00,0x00} 
.................... #DEFINE EP_HORA_LIGADO 0x04,0x02 
....................  
.................... //conta erros de comunicação com MCP - bytes 6 a 9 
.................... #ROM 0xF006 = {0x00,0x00,0x00,0x00} 
.................... #DEFINE EP_MCP 0x06,0x04 
....................  
.................... //SELETOR DE FREQUENCIA - byte 0A 
.................... #ROM 0xF006 = {0x00} 
.................... #DEFINE EP_ID 0x0A,0x01 
....................  
.................... #DEFINE int_per_sec 16 
....................  
.................... //******************************** 
....................  
.................... volatile unsigned int32 erro_nao_trans = 0, 
....................                         erro_mcp = 0; 
....................  
.................... volatile unsigned int16 horas_ligado = 0; 
....................  
.................... volatile unsigned int8 counter = 0, 
....................                        sec = 0, 
....................                        min = 0; 
....................                                                
.................... volatile unsigned int1 um_segundo = 0b0,  
....................                        um_minuto = 0b0, 
....................                        uma_hora = 0b0, 
....................                        flag_interr = 0b0, 
....................                        flag_envio = 0b0, 
....................                        flag_receb = 0b0, 
....................                        erro_nao_trans_flag = 0, 
....................                        erro_mcp_flag = 0; 
....................    
.................... void external_can_interrupt (); 
.................... int8 detecta_freq(void); 
.................... void setup_can(void); 
.................... void piscaLed(char nPisca, int16 delay, int8 led); 
.................... void eeprom_grava(unsigned int8 address, unsigned int8 tamanho, unsigned int32 hexa); 
.................... unsigned int32 eeprom_le(unsigned int8 address, unsigned int8 tamanho); 
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(){  // interrupt routine     
....................    set_timer1(3000); 
*
0023:  CLRF   16
0024:  MOVLW  0B
0025:  MOVWF  17
0026:  MOVLW  B8
0027:  MOVWF  16
....................    counter--;  // decrements counter which is set to it_per_sec  
0028:  DECFSZ 36,F
....................     
....................    //SEGUNDOS 
....................    if(counter==0){          
0029:  GOTO   02E
....................       sec++;                 
002A:  INCF   37,F
....................       counter=int_per_sec; //resets counter 
002B:  MOVLW  10
002C:  MOVWF  36
....................       //contador_seg++; 
....................       um_segundo = 0b01; 
002D:  BSF    39.0
....................    }  
....................  
....................    //MINUTOS 
....................    if(sec==60){  
002E:  MOVF   37,W
002F:  SUBLW  3C
0030:  BTFSS  03.2
0031:  GOTO   035
....................       sec=0;        
0032:  CLRF   37
....................       min++; 
0033:  INCF   38,F
....................       um_minuto = 0b1; 
0034:  BSF    39.1
....................    } 
....................      
....................    //HORAS 
....................    if(min==60) {  
0035:  MOVF   38,W
0036:  SUBLW  3C
0037:  BTFSC  03.2
....................       min=0; 
0038:  CLRF   38
....................       //atualizar dados da eeprom aqui 
....................    } 
.................... } 
....................  
0039:  BCF    11.0
003A:  MOVLP  00
003B:  GOTO   01A
.................... #int_ext 
.................... void external_can_interrupt () 
.................... { 
....................    flag_interr = 0b1; 
003C:  BSF    39.3
003D:  BCF    0B.1
003E:  MOVLP  00
003F:  GOTO   01A
.................... } 
....................  
.................... int8 detecta_freq(void) 
.................... { 
....................    int8 freq, i; 
....................    for(freq = 0; freq < 6; freq++) 
....................    { 
....................       can_set_mode(CAN_OP_CONFIG); 
....................       set_freq_var(freq); 
....................       can_set_baud(); 
....................       can_set_mode(CAN_OP_LISTEN); 
....................        
....................       for(i = 0; i < 8; i++) 
....................       { 
....................          delay_ms(500); 
....................          if(can_kbhit()) return freq; 
....................       }    
....................       piscaLed(1,1,LED2); 
....................    } 
....................    return 0xff; 
.................... } 
....................  
.................... void setup_can(int1 frequencia_eeprom, unsigned int8 interr, unsigned int8 can_mode) 
.................... { 
....................    int8 freq = 0; 
....................    can_init(); 
....................     
.................... //!   can_set_mode(CAN_OP_CONFIG); 
.................... //!   can_set_id(RX0MASK,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX0FILTER0,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX0FILTER1,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1MASK,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER2,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER3,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER4,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER5,0x223,CAN_USE_EXTENDED_ID); 
....................  
....................    frequencia_eeprom ? (freq = eeprom_le(EP_ID)) : (freq = detecta_freq()); 
....................    
....................    set_freq_var(freq); 
....................    can_set_interr(interr); 
....................    can_set_mode(can_mode);  
.................... } 
....................  
.................... void piscaLed(char nPisca, unsigned int16 delay, unsigned int8 led) 
*
0545:  CLRF   3E
.................... { 
....................      char i = 0; 
....................       
....................      for(i = 0; i < nPisca; i++){ 
0546:  CLRF   3E
0547:  MOVF   3A,W
0548:  SUBWF  3E,W
0549:  BTFSC  03.0
054A:  GOTO   579
....................          output_high(led); 
054B:  MOVF   3D,W
054C:  MOVWF  3F
054D:  MOVLW  01
054E:  MOVWF  40
054F:  MOVWF  42
0550:  CLRF   41
0551:  CALL   525
0552:  MOVF   3D,W
0553:  MOVWF  3F
0554:  CLRF   40
0555:  CLRF   42
0556:  MOVLW  80
0557:  MOVWF  41
0558:  CALL   525
....................          delay_ms(20); 
0559:  MOVLW  14
055A:  MOVWF  40
055B:  CALL   040
....................          output_low(led); 
055C:  MOVF   3D,W
055D:  MOVWF  3F
055E:  CLRF   40
055F:  MOVLW  01
0560:  MOVWF  42
0561:  CLRF   41
0562:  CALL   525
0563:  MOVF   3D,W
0564:  MOVWF  3F
0565:  CLRF   40
0566:  CLRF   42
0567:  MOVLW  80
0568:  MOVWF  41
0569:  CALL   525
....................          delay_ms(delay); 
056A:  MOVF   3C,W
056B:  MOVWF  3F
056C:  INCF   3F,F
056D:  DECF   3F,F
056E:  BTFSC  03.2
056F:  GOTO   574
0570:  MOVLW  FF
0571:  MOVWF  40
0572:  CALL   040
0573:  GOTO   56D
0574:  MOVF   3B,W
0575:  MOVWF  40
0576:  CALL   040
0577:  INCF   3E,F
0578:  GOTO   547
....................      } 
0579:  MOVLP  00
057A:  GOTO   657 (RETURN)
.................... } 
....................  
.................... void eeprom_grava(unsigned int8 address, unsigned int8 tamanho, unsigned int32 hexa) 
.................... { 
....................    unsigned int8 i = 0, bytes[4];                
....................     
....................    //separa bytes 
....................    for (i = 0; i < tamanho; i++) 
....................    { 
....................      bytes[i] = hexa; 
....................      hexa >>= 8; 
....................    } 
....................       
....................    //imprime na ordem inversa 
....................    while(tamanho)  
....................    { 
....................       write_eeprom(address++,bytes[--tamanho]); 
....................       delay_ms(1); 
....................    } 
.................... } 
....................  
.................... unsigned int32 eeprom_le(unsigned int8 address, unsigned int8 tamanho) 
.................... { 
....................    unsigned int8 i = 0; 
....................    unsigned int32 bytes = 0; 
....................     
....................    for(i = tamanho; i > 0; i--) 
....................    { 
....................       bytes <<= 8; 
....................       bytes |= read_eeprom(address++);  
....................       delay_ms(1); 
....................    } 
....................    return bytes; 
.................... } 
....................  
....................  
....................  
.................... #define MASTER 200 
.................... #define RECEPTOR1 303 
....................  
.................... void trata_dado() 
.................... { 
....................    struct rx_stat rxstat; 
....................    int32 tx_id; 
....................    int8 rx_len;    
....................    int32 rx_id; 
....................    int8 dadosEnv[8] = {0xAA,0xBB}, 
*
02B6:  MOVLW  AA
02B7:  MOVWF  44
02B8:  MOVLW  BB
02B9:  MOVWF  45
02BA:  CLRF   46
02BB:  CLRF   47
02BC:  CLRF   48
02BD:  CLRF   49
02BE:  CLRF   4A
02BF:  CLRF   4B
....................         dadosRec[8] = {0xAA,0xBB}; 
02C0:  MOVLW  AA
02C1:  MOVWF  4C
02C2:  MOVLW  BB
02C3:  MOVWF  4D
02C4:  CLRF   4E
02C5:  CLRF   4F
02C6:  CLRF   50
02C7:  CLRF   51
02C8:  CLRF   52
02C9:  CLRF   53
....................          
....................    flag_receb = 0b0;   
02CA:  BCF    39.5
....................    if(can_getd (rx_id, dadosRec, rx_len, rxstat)) 
02CB:  MOVLW  20
02CC:  MOVWF  55
02CD:  MOVLW  2C
02CE:  MOVWF  54
*
0505:  MOVF   21,F
0506:  BTFSC  03.2
0507:  GOTO   523
....................    { 
....................       if(dadosRec[0] == 0xAA) 
0508:  MOVF   4C,W
0509:  SUBLW  AA
050A:  BTFSS  03.2
050B:  GOTO   516
....................       { 
....................          output_high(LED2); 
050C:  MOVLB  01
050D:  BCF    0C.4
050E:  MOVLB  02
050F:  BSF    0C.4
....................          output_low(SAIDA1); 
0510:  MOVLB  01
0511:  BCF    0E.5
0512:  MOVLB  02
0513:  BCF    0E.5
....................       } 
0514:  GOTO   522
0515:  MOVLB  00
....................       else if(dadosRec[0] == 0xBB) 
0516:  MOVF   4C,W
0517:  SUBLW  BB
0518:  BTFSS  03.2
0519:  GOTO   523
....................       { 
....................          output_low(LED2); 
051A:  MOVLB  01
051B:  BCF    0C.4
051C:  MOVLB  02
051D:  BCF    0C.4
....................          output_high(SAIDA1); 
051E:  MOVLB  01
051F:  BCF    0E.5
0520:  MOVLB  02
0521:  BSF    0E.5
0522:  MOVLB  00
....................       } 
....................          
....................    } 
0523:  MOVLP  00
0524:  GOTO   64C (RETURN)
....................      
.................... } 
....................  
.................... //interrupcoes 
.................... unsigned int8 trata_interr() 
*
0272:  CLRF   3C
.................... { 
....................    unsigned int8 int_id,i,int_unitario = 0x00;  
....................     
....................    int_id = mcp2510_read(CANINTF); 
0273:  MOVLW  2C
0274:  MOVLB  01
0275:  MOVWF  25
0276:  MOVLB  00
0277:  CALL   080
0278:  MOVF   21,W
0279:  MOVWF  3A
....................    if(int_id) 
027A:  MOVF   3A,F
027B:  BTFSC  03.2
027C:  GOTO   28B
....................    { 
....................       for (i = 1; i != 0; i<<=1) 
027D:  MOVLW  01
027E:  MOVWF  3B
027F:  MOVF   3B,F
0280:  BTFSC  03.2
0281:  GOTO   28B
....................       { 
....................          if ((int_id & i) != 0) {int_unitario = i;} 
0282:  MOVF   3A,W
0283:  ANDWF  3B,W
0284:  BTFSC  03.2
0285:  GOTO   288
0286:  MOVF   3B,W
0287:  MOVWF  3C
0288:  BCF    03.0
0289:  RLF    3B,F
028A:  GOTO   27F
....................       }    
....................    } 
....................  
....................    switch (int_unitario) 
028B:  MOVF   3C,W
028C:  XORLW  01
028D:  BTFSC  03.2
028E:  GOTO   2A5
028F:  XORLW  03
0290:  BTFSC  03.2
0291:  GOTO   2A7
0292:  XORLW  06
0293:  BTFSC  03.2
0294:  GOTO   2A9
0295:  XORLW  0C
0296:  BTFSC  03.2
0297:  GOTO   2AA
0298:  XORLW  18
0299:  BTFSC  03.2
029A:  GOTO   2AB
029B:  XORLW  30
029C:  BTFSC  03.2
029D:  GOTO   2AC
029E:  XORLW  60
029F:  BTFSC  03.2
02A0:  GOTO   2AD
02A1:  XORLW  C0
02A2:  BTFSC  03.2
02A3:  GOTO   2AE
02A4:  GOTO   2AF
....................    { 
....................       case CAN_RX0_INT: 
....................          flag_receb = 0b1; 
02A5:  BSF    39.5
....................          break; 
02A6:  GOTO   2AF
....................        
....................       case CAN_RX1_INT: 
....................          flag_receb = 0b1; 
02A7:  BSF    39.5
....................          break; 
02A8:  GOTO   2AF
....................        
....................       case CAN_TX0_INT: 
....................          break; 
02A9:  GOTO   2AF
....................        
....................       case CAN_TX1_INT: 
....................          break; 
02AA:  GOTO   2AF
....................    
....................       case CAN_TX2_INT: 
....................          break; 
02AB:  GOTO   2AF
....................        
....................       case CAN_ERROR_INT: 
....................          break; 
02AC:  GOTO   2AF
....................        
....................       case CAN_WAKE_INT: 
....................          break; 
02AD:  GOTO   2AF
....................        
....................       case CAN_MESERR_INT: 
....................          break; 
02AE:  GOTO   2AF
....................        
....................       default:  
....................          break; //erro! 
....................    } 
....................     
....................    //mcp2510_bitmodify(CANINTF,int_unitario,0x00); 
....................    int_id &= ~int_unitario; 
02AF:  MOVF   3C,W
02B0:  XORLW  FF
02B1:  ANDWF  3A,F
....................    return int_id; 
02B2:  MOVF   3A,W
02B3:  MOVWF  21
02B4:  MOVLP  00
02B5:  GOTO   64A (RETURN)
.................... } 
....................  
.................... //!void trata_interr() 
.................... //!{ 
.................... //!   int int_id = mcp2510_read(CANINTF); 
.................... //!   mcp2510_bitmodify(CANINTF,int_id,0x00); 
.................... //!    
.................... //!   flag_interr = 0b0; 
.................... //!    
.................... //!   if(int_id & CAN_MESERR_INT) 
.................... //!   { 
.................... //!      output_low(PIN_A1); 
.................... //!   } 
.................... //!    
.................... //!    
.................... //!   //else if(int_id & CAN_WAKE_INT) {} 
.................... //!   //else if(int_id & CAN_ERROR_INT) {} 
.................... //!   //else if(int_id & CAN_TX2_INT) {} 
.................... //!   //else if(int_id & CAN_TX1_INT) {} 
.................... //!   //else if(int_id & CAN_TX0_INT) {} 
.................... //!   //else if(int_id & CAN_RX1_INT) {} 
.................... //!   //else if(int_id & CAN_RX0_INT) {} 
.................... //!} 
....................  
....................  
.................... void main() 
*
057B:  MOVLW  6A
057C:  MOVLB  01
057D:  MOVWF  19
057E:  MOVLB  02
057F:  BSF    00.0
0580:  MOVLB  00
0581:  CLRF   28
0582:  MOVLW  01
0583:  MOVWF  29
0584:  MOVWF  2A
0585:  MOVLW  02
0586:  MOVWF  2B
0587:  MOVLB  01
0588:  BSF    0E.1
0589:  BCF    0E.2
058A:  BCF    0E.0
058B:  MOVLB  02
058C:  BCF    0E.0
058D:  MOVLB  00
058E:  CLRF   2F
058F:  CLRF   2E
0590:  CLRF   2D
0591:  CLRF   2C
0592:  CLRF   33
0593:  CLRF   32
0594:  CLRF   31
0595:  CLRF   30
0596:  CLRF   35
0597:  CLRF   34
0598:  CLRF   36
0599:  CLRF   37
059A:  CLRF   38
059B:  BCF    39.0
059C:  BCF    39.1
059D:  BCF    39.2
059E:  BCF    39.3
059F:  BCF    39.4
05A0:  BCF    39.5
05A1:  BCF    39.6
05A2:  BCF    39.7
05A3:  MOVLB  03
05A4:  CLRF   0C
05A5:  CLRF   0E
05A6:  MOVLB  02
05A7:  CLRF   12
05A8:  CLRF   11
05A9:  CLRF   14
05AA:  CLRF   13
.................... {   
....................    //VEJA placa_plus.h 
....................    set_tris_a(0b00001100); 
05AB:  MOVLW  0C
05AC:  TRIS   5
....................    set_tris_c(0b00000010); 
05AD:  MOVLW  02
05AE:  TRIS   7
....................    output_low(LED1); 
05AF:  MOVLB  01
05B0:  BCF    0C.5
05B1:  MOVLB  02
05B2:  BCF    0C.5
....................    output_low(LED2); 
05B3:  MOVLB  01
05B4:  BCF    0C.4
05B5:  MOVLB  02
05B6:  BCF    0C.4
....................     
....................    output_high(LED1); 
05B7:  MOVLB  01
05B8:  BCF    0C.5
05B9:  MOVLB  02
05BA:  BSF    0C.5
....................    delay_ms(200); 
05BB:  MOVLW  C8
05BC:  MOVLB  00
05BD:  MOVWF  40
05BE:  CALL   040
....................  
....................    can_init(); 
05BF:  GOTO   1B4
....................  
....................    output_low(LED1); 
05C0:  MOVLB  01
05C1:  BCF    0C.5
05C2:  MOVLB  02
05C3:  BCF    0C.5
....................    delay_ms(200); 
05C4:  MOVLW  C8
05C5:  MOVLB  00
05C6:  MOVWF  40
05C7:  CALL   040
....................     
....................    can_set_mode(CAN_OP_CONFIG); 
05C8:  MOVLW  04
05C9:  MOVWF  3B
05CA:  CALL   0CA
....................    can_set_id(RX0MASK,0x71F,CAN_USE_EXTENDED_ID); 
05CB:  MOVLW  23
05CC:  MOVWF  3B
05CD:  CLRF   3F
05CE:  CLRF   3E
05CF:  MOVLW  07
05D0:  MOVWF  3D
05D1:  MOVLW  1F
05D2:  MOVWF  3C
05D3:  CLRF   40
05D4:  CALL   101
....................    can_set_id(RX0FILTER0,0x71F,CAN_USE_EXTENDED_ID); 
05D5:  MOVLW  03
05D6:  MOVWF  3B
05D7:  CLRF   3F
05D8:  CLRF   3E
05D9:  MOVLW  07
05DA:  MOVWF  3D
05DB:  MOVLW  1F
05DC:  MOVWF  3C
05DD:  CLRF   40
05DE:  CALL   101
....................    can_set_id(RX0FILTER1,0x71F,CAN_USE_EXTENDED_ID); 
05DF:  MOVLW  07
05E0:  MOVWF  3B
05E1:  CLRF   3F
05E2:  CLRF   3E
05E3:  MOVWF  3D
05E4:  MOVLW  1F
05E5:  MOVWF  3C
05E6:  CLRF   40
05E7:  CALL   101
....................    can_set_id(RX1MASK,0x71F,CAN_USE_EXTENDED_ID); 
05E8:  MOVLW  27
05E9:  MOVWF  3B
05EA:  CLRF   3F
05EB:  CLRF   3E
05EC:  MOVLW  07
05ED:  MOVWF  3D
05EE:  MOVLW  1F
05EF:  MOVWF  3C
05F0:  CLRF   40
05F1:  CALL   101
....................    can_set_id(RX1FILTER2,0x71F,CAN_USE_EXTENDED_ID); 
05F2:  MOVLW  0B
05F3:  MOVWF  3B
05F4:  CLRF   3F
05F5:  CLRF   3E
05F6:  MOVLW  07
05F7:  MOVWF  3D
05F8:  MOVLW  1F
05F9:  MOVWF  3C
05FA:  CLRF   40
05FB:  CALL   101
....................    can_set_id(RX1FILTER3,0x71F,CAN_USE_EXTENDED_ID); 
05FC:  MOVLW  13
05FD:  MOVWF  3B
05FE:  CLRF   3F
05FF:  CLRF   3E
0600:  MOVLW  07
0601:  MOVWF  3D
0602:  MOVLW  1F
0603:  MOVWF  3C
0604:  CLRF   40
0605:  CALL   101
....................    can_set_id(RX1FILTER4,0x71F,CAN_USE_EXTENDED_ID); 
0606:  MOVLW  17
0607:  MOVWF  3B
0608:  CLRF   3F
0609:  CLRF   3E
060A:  MOVLW  07
060B:  MOVWF  3D
060C:  MOVLW  1F
060D:  MOVWF  3C
060E:  CLRF   40
060F:  CALL   101
....................    can_set_id(RX1FILTER5,0x71F,CAN_USE_EXTENDED_ID); 
0610:  MOVLW  1B
0611:  MOVWF  3B
0612:  CLRF   3F
0613:  CLRF   3E
0614:  MOVLW  07
0615:  MOVWF  3D
0616:  MOVLW  1F
0617:  MOVWF  3C
0618:  CLRF   40
0619:  CALL   101
....................    can_set_interr(0x03); 
061A:  MOVLW  03
061B:  MOVWF  3A
061C:  GOTO   26B
....................    can_set_mode(CAN_OP_NORMAL); 
061D:  CLRF   3B
061E:  CALL   0CA
....................  
....................    output_high(LED1); 
061F:  MOVLB  01
0620:  BCF    0C.5
0621:  MOVLB  02
0622:  BSF    0C.5
....................    delay_ms(200); 
0623:  MOVLW  C8
0624:  MOVLB  00
0625:  MOVWF  40
0626:  CALL   040
....................     
.................... //===========REGISTRADORES=================================== 
....................    disable_interrupts(GLOBAL);                 // habilitar interr global 
0627:  BCF    0B.6
0628:  BCF    0B.7
0629:  BTFSC  0B.7
062A:  GOTO   628
....................    enable_interrupts(INT_EXT_H2L);             // interrupï¿½ï¿½o CAN 
062B:  BSF    0B.4
062C:  MOVLB  01
062D:  BCF    15.6
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);   // setar timer1 para interno 
062E:  MOVLB  02
062F:  BCF    1D.3
0630:  MOVLW  05
0631:  MOVLB  00
0632:  MOVWF  18
0633:  CLRF   19
....................    enable_interrupts(INT_TIMER1);              // habilita Timer1  
0634:  MOVLB  01
0635:  BSF    11.0
....................    set_timer1(0);                              // limpar flag TMR1H & TMR1L  
0636:  MOVLB  00
0637:  CLRF   16
0638:  CLRF   17
0639:  CLRF   16
....................    counter=int_per_sec; 
063A:  MOVLW  10
063B:  MOVWF  36
....................    enable_interrupts(GLOBAL);                  // habilitar interr global 
063C:  MOVLW  C0
063D:  IORWF  0B,F
.................... //---------------------------------------------------------- 
....................  
....................    output_low(LED1); 
063E:  MOVLB  01
063F:  BCF    0C.5
0640:  MOVLB  02
0641:  BCF    0C.5
....................    delay_ms(200); 
0642:  MOVLW  C8
0643:  MOVLB  00
0644:  MOVWF  40
0645:  CALL   040
....................  
....................    while(TRUE) 
....................    { 
....................       if(flag_interr) 
0646:  BTFSS  39.3
0647:  GOTO   64A
....................       {     
....................          flag_interr = 0b0; 
0648:  BCF    39.3
....................          trata_interr();         
0649:  GOTO   272
....................       } 
....................        
....................       if(flag_receb) 
064A:  BTFSC  39.5
....................       { 
....................          trata_dado(); 
064B:  GOTO   2B6
....................          //piscaLed(1,1,LED2); 
....................       } 
....................           
....................       if(um_segundo) 
064C:  BTFSS  39.0
064D:  GOTO   657
....................       {       
....................          um_segundo = 0b0; 
064E:  BCF    39.0
....................          piscaLed(1,500 
....................          ,LED1);  
064F:  MOVLW  01
0650:  MOVWF  3A
0651:  MOVWF  3C
0652:  MOVLW  F4
0653:  MOVWF  3B
0654:  MOVLW  65
0655:  MOVWF  3D
0656:  GOTO   545
....................       } 
0657:  GOTO   646
....................    } 
.................... } 
....................  
0658:  SLEEP
....................  

Configuration Fuses:
   Word  1: 3984   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
00F000: 0000 0000 0000 0000 0000 0000 0000 0000 
00F008: 0000 0000 

00F006: 0000 
