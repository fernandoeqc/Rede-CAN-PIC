CCS PCM C Compiler, Version 5.015, 5967               24-jul-20 10:17

               Filename:   c:\Users\fernandoLab\Documents\GitHub\Rede-CAN-PIC\teste_can_rec.lst

               ROM used:   1621 words (79%)
                           Largest free fragment is 426
               RAM used:   27 (21%) at main() level
                           108 (84%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   581
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   20,W
0008:  MOVWF  24
0009:  MOVF   21,W
000A:  MOVWF  25
000B:  MOVF   22,W
000C:  MOVWF  26
000D:  MOVF   23,W
000E:  MOVWF  27
000F:  BTFSS  0B.4
0010:  GOTO   013
0011:  BTFSC  0B.1
0012:  GOTO   03C
0013:  CLRF   05
0014:  MOVLW  91
0015:  MOVWF  04
0016:  BTFSS  00.0
0017:  GOTO   01A
0018:  BTFSC  11.0
0019:  GOTO   023
001A:  MOVF   24,W
001B:  MOVWF  20
001C:  MOVF   25,W
001D:  MOVWF  21
001E:  MOVF   26,W
001F:  MOVWF  22
0020:  MOVF   27,W
0021:  MOVWF  23
0022:  RETFIE
.................... #include <teste_can_rec.h> 
.................... #include <16F1823.h> 
.................... //////////// Standard Header file for the PIC16F1823 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1823 
*
00A4:  MOVF   21,W
00A5:  BTFSC  03.2
00A6:  GOTO   0AB
00A7:  MOVF   20,W
00A8:  MOVWI  W,[FSR0++]
00A9:  DECFSZ 21,F
00AA:  GOTO   0A7
00AB:  RETURN
*
02B7:  MOVF   59,W
02B8:  ANDLW  07
02B9:  MOVWF  20
02BA:  RRF    59,W
02BB:  MOVWF  21
02BC:  RRF    21,F
02BD:  RRF    21,F
02BE:  MOVLW  1F
02BF:  ANDWF  21,F
02C0:  MOVF   21,W
02C1:  ADDWF  5B,W
02C2:  MOVWF  04
02C3:  MOVLW  00
02C4:  ADDWFC 5C,W
02C5:  MOVWF  05
02C6:  CLRF   21
02C7:  INCF   21,F
02C8:  INCF   20,F
02C9:  GOTO   2CB
02CA:  RLF    21,F
02CB:  DECFSZ 20,F
02CC:  GOTO   2CA
02CD:  MOVF   5A,F
02CE:  BTFSC  03.2
02CF:  GOTO   2D3
02D0:  MOVF   21,W
02D1:  IORWF  00,F
02D2:  GOTO   2D6
02D3:  COMF   21,F
02D4:  MOVF   21,W
02D5:  ANDWF  00,F
02D6:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(internal=4000000) 
*
0040:  MOVLW  20
0041:  MOVWF  05
0042:  MOVLW  3A
0043:  MOVWF  04
0044:  MOVF   00,W
0045:  BTFSC  03.2
0046:  GOTO   055
0047:  MOVLW  01
0048:  MOVWF  21
0049:  CLRF   20
004A:  DECFSZ 20,F
004B:  GOTO   04A
004C:  DECFSZ 21,F
004D:  GOTO   049
004E:  MOVLW  4A
004F:  MOVWF  20
0050:  DECFSZ 20,F
0051:  GOTO   050
0052:  GOTO   053
0053:  DECFSZ 00,F
0054:  GOTO   047
0055:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=0,rcv=1,bits=8,stream=PORT1) 
....................  
.................... #define LED1 PIN_A5 
.................... #define LED2 PIN_A4 
.................... #define SAIDA1 PIN_C5 
....................  
.................... // PORTA 
.................... #define   IRQ         PIN_A2 
.................... #define   CE          PIN_A1 
.................... #define   MCLR        PIN_A3 
.................... // PORTC 
.................... #define   SCK         PIN_C0 
.................... #define   SDI         PIN_C1 
.................... #define   SDO         PIN_C2 
.................... #define   CS          PIN_C3 
....................                        
.................... //TRISA 
.................... #define   CE_TRIS     TRISA,1 //O 
.................... #define   IRQ_TRIS    TRISA,2 //I 
....................  
.................... //TRISC 
.................... #define   SCK_TRIS    TRISC,0 //O 
.................... #define   SDI_TRIS    TRISC,1 //I 
.................... #define   SDO_TRIS    TRISC,2 //O 
.................... #define   CS_TRIS     TRISC,3 //O 
....................  
.................... //***************** 
.................... //*   VARIABLES   * 
.................... //***************** 
.................... #BYTE TRISA     =  0x0C //00000110 
.................... //#BYTE TRISB     =  0x86 
.................... #BYTE TRISC     =  0x02 //00000010 
.................... #BYTE INTCON    =  0x00 
....................  
.................... #include <can-mcp2515.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-mcp2510.c                            //// 
.................... //// CAN Library routines for Microchip's MCP2510 (and compatable)   //// 
.................... //// CAN IO expanders.                                               //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the MCP2510 CAN peripheral             //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// You will need a CAN transeiver to connect CANRX and CANTX       //// 
.................... //// pins to CANH and CANL bus lines.                                //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can_ccs_b.c, which shows how to use //// 
.................... //// this library with CCS's CAN Prototype board.                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 04 - Fixed a compling problem.                          //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 17 09 - Updated for PCD Compiler                           //// 
.................... ////                                                                 //// 
.................... ////  May 20 10 - Changed all variable types to unsigned for PCD and //// 
.................... ////              if #device ANSI is used with PCH or PCM            //// 
.................... ////                                                                 //// 
.................... ////  Nov 10 10 - Modified SPI protocol to use #use SPI()            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-mcp2515.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-mcp2510.h                            //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for the MCP2510 (and compatable) CAN IO     //// 
.................... //// expanders.                                                      //// 
.................... ////                                                                 //// 
.................... //// (see can-mcp2510.c)                                             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 04 - Fixed a compling problem                           //// 
.................... ////                                                                 //// 
.................... ////  Jul 17 09 - Updated for PCD Compiler                           //// 
.................... ////                                                                 //// 
.................... ////  May 20 10 - Changed all variable types to unsigned for PCD and //// 
.................... ////              if #device ANSI is used with PCH or PCM            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... //#define CAN_DO_DEBUG TRUE 
....................  
....................  
.................... //defines BAUD RATE 
....................  
.................... #define MCP_8MHz_500kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_500kBPS_CFG2 (0x90) 
.................... #define MCP_8MHz_500kBPS_CFG3 (0x02) 
....................  
.................... #define MCP_8MHz_250kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_250kBPS_CFG2 (0xb1) 
.................... #define MCP_8MHz_250kBPS_CFG3 (0x05) 
....................  
.................... #define MCP_8MHz_200kBPS_CFG1 (0x00) 
.................... #define MCP_8MHz_200kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_200kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_125kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_125kBPS_CFG2 (0xb1) 
.................... #define MCP_8MHz_125kBPS_CFG3 (0x05) 
....................  
.................... #define MCP_8MHz_100kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_100kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_100kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_80kBPS_CFG1 (0x01) 
.................... #define MCP_8MHz_80kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_80kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_50kBPS_CFG1 (0x03) 
.................... #define MCP_8MHz_50kBPS_CFG2 (0xb4) 
.................... #define MCP_8MHz_50kBPS_CFG3 (0x06) 
....................  
.................... #define MCP_8MHz_40kBPS_CFG1 (0x03) 
.................... #define MCP_8MHz_40kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_40kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_20kBPS_CFG1 (0x07) 
.................... #define MCP_8MHz_20kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_20kBPS_CFG3 (0x07) 
....................  
.................... #define MCP_8MHz_10kBPS_CFG1 (0x0f) 
.................... #define MCP_8MHz_10kBPS_CFG2 (0xbf) 
.................... #define MCP_8MHz_10kBPS_CFG3 (0x07) 
....................  
....................  
....................  
.................... #ifndef __CCS_CANMCP2510_LIB_DEFINES__ 
.................... #define __CCS_CANMCP2510_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         FALSE 
.................... #ENDIF 
....................  
.................... /////////////// register CNF1  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... ////BRP 
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   int8 CAN_BRG_PRESCALAR = 0;  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... /////////////// register CNF2 
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... ////PS1 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  int8 CAN_BRG_PHASE_SEGMENT_1 = 1; //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... ////PSG    
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  int8 CAN_BRG_PROPAGATION_TIME = 1; //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... /////////////// register CNF3 
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... ////PS2 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  int8 CAN_BRG_PHASE_SEGMENT_2 = 2; //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_SLEEP=1, CAN_OP_NORMAL=0}; 
....................  
.................... //can control 
.................... struct struct_CANCTRL { 
....................    int  clkpre:2; //0:1 //clkout pin prescalar 
....................    int1 clken; //2   //clkout pin enable 
....................    int1 osm; //3 
....................    int1 abat;  //4   //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3; //5:7 //request operation mode 
.................... }; 
.................... #define CANCTRL   0x0F  //or 1f, or 2f, or 3f ... or 7f 
....................  
.................... enum CAN_INT_CODE {CAN_INT_RX1=7, CAN_INT_RX0=6, CAN_INT_TX2=5, CAN_INT_TX1=4, CAN_INT_TX0=3, CAN_INT_WAKEUP=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct struct_CANSTAT { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... }; 
.................... #define CANSTAT 0x0E //or 1e, or 2e ... or 7e 
....................  
.................... //error flag register 
.................... struct struct_EFLG { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwar;      //1 //receiver warning 
....................    int1 txwar;      //2 //transmitter warning 
....................    int1 rxep;   //3 //receive error passive flag 
....................    int1 txep;   //4 //transmit error passive flag 
....................    int1 txbo;   //5   //bus off error flag 
....................    int1 rx0ovr;   //6   //receive buffer 0 overflow 
....................    int1 rx1ovr;   //7   //receive buffer 1 overflow 
.................... }; 
.................... #define EFLG   0x2D 
....................  
.................... //interupt enable register 
.................... struct struct_CANINTE { 
....................    int1 rx0ie; //0   //receive buffer 0 full interrupt enable 
....................    int1 rx1ie; //1   //receive buffer 1 full interrupt enable 
....................    int1 tx0ie; //2   //transmit buffer 0 embty interrupt enable 
....................    int1 tx1ie; //3   //transmit buffer 1 embty interrupt enable 
....................    int1 tx2ie; //4   //transmit buffer 2 embty interrupt enable 
....................    int1 errie; //5   //error interrupt enable 
....................    int1 wakie; //6   //wakeup interrupt  enable 
....................    int1 merre; //7   //message error interrupt enable 
.................... }; 
.................... #define CANINTE   0x2B 
....................  
.................... //interupt enable register 
.................... struct struct_CANINTF { 
....................    int1 rx0if; //0   //receive buffer 0 full interrupt flag 
....................    int1 rx1if; //1   //receive buffer 1 full interrupt flag 
....................    int1 tx0if; //2   //transmit buffer 0 embty interrupt flag 
....................    int1 tx1if; //3   //transmit buffer 1 embty interrupt flag 
....................    int1 tx2if; //4   //transmit buffer 2 embty interrupt flag 
....................    int1 errif; //5   //error interrupt flag 
....................    int1 wakif; //6   //wakeup interrupt flag 
....................    int1 merrf; //7   //message error interrupt flag 
.................... }; 
.................... #define CANINTF   0x2C 
....................  
.................... #DEFINE CAN_RX0_INT    1 
.................... #DEFINE CAN_RX1_INT    2 
.................... #DEFINE CAN_TX0_INT    4 
.................... #DEFINE CAN_TX1_INT    8  
.................... #DEFINE CAN_TX2_INT    16 
.................... #DEFINE CAN_ERROR_INT  32 
.................... #DEFINE CAN_WAKE_INT   64 
.................... #DEFINE CAN_MESERR_INT 128 
....................  
.................... //error counters 
.................... #define TEC    0x1C 
.................... #define REC    0x1D 
....................  
.................... //baud rate control register 1 
.................... struct struct_CNF1 { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... }; 
.................... #define CNF1   0x2A 
....................  
.................... //baud rate control register 2 
.................... struct struct_CNF2 { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int phseg1:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 btlmode; //7 //phase segment 2 bit time length 
.................... }; 
.................... #define CNF2   0x29 
....................  
.................... //baud rate control register 3 
.................... struct struct_CNF3 { 
....................    int phseg2:3;     //0:2 //phase segment 2 time select 
....................    int void543:3;    //3:5 
....................    int1 wakfil;      //6   //selects can bus line filter for wake-up 
....................    int1 sof;         //7 
.................... }; 
.................... #define CNF3   0x28 
.................... //can i/o control register 
....................  
.................... //transmit buffer n control register 
.................... struct txbNctrl_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 mloa;   //5   //message lost arbitration 
....................    int1 abtf;   //6   //message was aborted / or transmitted succesfully 
....................    int1 void7; 
.................... }; 
.................... #define TXB0CTRL  0x30 
.................... #define TXB1CTRL  0x40 
.................... #define TXB2CTRL  0x50 
....................  
.................... //TXnRTS pin control and status register 
.................... struct struct_TXRTSCTRL { 
....................    int1 b0rtsm; //0  //1=request message trans, 0=digital 
....................    int1 b1rtsm; //1  //1=request message trans, 0=digital 
....................    int1 b2rtsm; //2  //1=request message trans, 0=digital 
....................    int1 b0rts; //3   //reads as tx2rts when in digital, 0 when in rts 
....................    int1 b1rts; //4   //reads as tx2rts when in digital, 0 when in rts mode 
....................    int1 b2rts; //5  //reads as tx2rts when in digital, 0 when in rts mode 
....................    int  void67:2; //6:7 
.................... }; 
.................... #define TXRTSCTRL 0x0D 
....................  
.................... //transmit buffer n standard identifier 
.................... #define TXB0SIDH 0x31 
.................... #define TXB0SIDL 0x32 
.................... #define TXB1SIDH 0x41 
.................... #define TXB1SIDL 0x42 
.................... #define TXB2SIDH 0x51 
.................... #define TXB2SIDL 0x52 
....................  
.................... //transmit buffer n extended identifier 
.................... #define TXB0EIDH 0x33 
.................... #define TXB0EIDL 0x34 
.................... #define TXB1EIDH 0x43 
.................... #define TXB1EIDL 0x44 
.................... #define TXB2EIDH 0x53 
.................... #define TXB2EIDL 0x54 
....................  
.................... //transmit buffer n data byte m 
.................... #define TXB0D0 0x36 
.................... #define TXB0D7 0x3D 
....................  
.................... #define TXB1D0 0x46 
.................... #define TXB1D7 0x4D 
....................  
.................... #define TXB2D0 0x56 
.................... #define TXB2D7 0x5D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... #define TXB0DLC 0x35 
.................... #define TXB1DLC 0x45 
.................... #define TXB2DLC 0x55 
....................  
.................... //#byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct struct_RXB0CTRL { 
....................    int1 filhit0;   //0 //filter hit 
....................    int1 bukt1;   //1 //read only copy of bukt bit (used internally by mcp2510) 
....................    int1 bukt;   //2 //rollover enable 
....................    int1 rxrtr;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 void7;   //7 //receive full status 
.................... }; 
.................... #define RXB0CTRL  0x60 
....................  
.................... //receive buffer 1 control register 
.................... struct struct_RXB1CTRL { 
....................    int filhit0:3;   //0:2 
....................    int1 rxrtr;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 void7;   //7 
.................... }; 
.................... #define RXB1CTRL 0x70 
....................  
.................... //RXnBF pint control and status register 
.................... struct struct_BFPCTRL { 
....................    int1  b0bfm; //0   //1=pin is interrupt when message loaded into rxb0, 0=digital 
....................    int1  b1bfm; //1   //1=pin is interrupt when message loaded into rxb1, 0=digital 
....................    int1  b0bfe; //2   //rx0bf pin function enable 
....................    int1  b1bfe; //3   //rx1bf pin function enable 
....................    int1  b0bfs; //4   //rx0bf pin state 
....................    int1  b1bfs; //5   //rx1bf pin state 
.................... }; 
....................  
.................... //receive buffer n standard identifier 
.................... #define   RXB0SIDH  0x61 
.................... #define   RXB0SIDL  0x62 
....................  
.................... #define   RXB1SIDH  0x71 
.................... #define   RXB1SIDL  0x72 
....................  
.................... //receive buffer n extended identifier 
.................... #define   RXB0EID8  0x63 
.................... #define   RXB0EID0  0x64 
....................  
.................... #define   RXB1EID8  0x73 
.................... #define   RXB1EID0  0x74 
....................  
.................... struct struct_TXRXBaSIDL { 
....................    int void012:3; //0:2 
....................    int1 ext;      //3 //extendid id 
....................    int1 srr;      //4 //substitute remove request bit 
....................    int void567:3; //5:7 
.................... }; 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0;   //4   //reserved 
....................    int1 rb1;   //5   //reserved 
....................    int1 rtr;   //6   //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... #define   RXB0DLC   0x65 
.................... #define   RXB1DLC   0x75 
....................  
.................... //receive buffer n data field byte m register 
.................... #define RXB0D0    0x66 
.................... #define RXB0D7    0x6D 
....................  
.................... #define RXB1D0    0x76 
.................... #define RXB1D7    0x7D 
....................  
....................  
.................... //receive acceptance filter n standard indifier 
.................... #define RXF0SIDH  0x00 
.................... #define RXF0SIDL  0x01 
.................... #define RXF1SIDH  0x04 
.................... #define RXF1SIDL  0x05 
.................... #define RXF2SIDH  0x08 
.................... #define RXF2SIDL  0x09 
.................... #define RXF3SIDH  0x10 
.................... #define RXF3SIDL  0x11 
.................... #define RXF4SIDH  0x14 
.................... #define RXF4SIDL  0x15 
.................... #define RXF5SIDH  0x18 
.................... #define RXF5SIDL  0x19 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #define RXF0EIDH  0x02 
.................... #define RXF0EIDL  0x03 
.................... #define RXF1EIDH  0x06 
.................... #define RXF1EIDL  0x07 
.................... #define RXF2EIDH  0x0a 
.................... #define RXF2EIDL  0x0b 
.................... #define RXF3EIDH  0x12 
.................... #define RXF3EIDL  0x13 
.................... #define RXF4EIDH  0x16 
.................... #define RXF4EIDL  0x17 
.................... #define RXF5EIDH  0x1a 
.................... #define RXF5EIDL  0x1b 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #define RXM0SIDH  0x20 
.................... #define RXM0SIDL  0x21 
.................... #define RXM1SIDH  0x24 
.................... #define RXM1SIDL  0x25 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #define RXM0EIDH  0x22 
.................... #define RXM0EIDL  0x23 
.................... #define RXM1EIDH  0x26 
.................... #define RXM1EIDL  0x27 
....................  
.................... #define RX0MASK       RXM0EIDL   //rxm0eidl 
.................... #define RX1MASK       RXM1EIDL   //rxm1eidl 
.................... #define RX0FILTER0    RXF0EIDL   //rxf0eidl 
.................... #define RX0FILTER1    RXF1EIDL   //rxf1eidl 
.................... #define RX1FILTER2    RXF2EIDL   //rxf2eidl 
.................... #define RX1FILTER3    RXF3EIDL   //rxf3eidl 
.................... #define RX1FILTER4    RXF4EIDL   //rxf4eidl 
.................... #define RX1FILTER5    RXF5EIDL   //rxf5eidl 
.................... #define RXB0ID        RXB0EIDL   //rxb0eidl 
.................... #define RXB1ID        RXB1EIDL   //rxb1eidl 
.................... #define TXB0ID        TXB0EIDL   //txb0eidl 
.................... #define TXB1ID        TXB1EIDL   //txb1eidl 
.................... #define TXB2ID        TXB2EIDL   //tsb2eidl 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
....................  
.................... //PROTOTYPES and MACROS 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void can_set_id(unsigned int8 addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int8 addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int8 * data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int8 * data, unsigned int8 & len, struct rx_stat & stat); 
....................  
.................... void mcp2510_init(); 
.................... void mcp2510_command(unsigned int8 command); 
.................... void mcp2510_write(unsigned int8 address, unsigned int8 data); 
.................... unsigned int8 mcp2510_status(void); 
.................... unsigned int8 mcp2510_read(unsigned int8 address); 
....................  
.................... #endif 
....................  
....................  
.................... //IO pins connected to MCP2510 
.................... #ifndef EXT_CAN_CS 
....................    #if defined(__PCD__) 
....................       #define EXT_CAN_CS   CS 
....................       #define EXT_CAN_SI   SDI 
....................       #define EXT_CAN_SO   SDO 
....................       #define EXT_CAN_SCK  SCK 
....................    #else 
....................       #define EXT_CAN_CS   CS 
....................       #define EXT_CAN_SI   SDI 
....................       #define EXT_CAN_SO   SDO 
....................       #define EXT_CAN_SCK  SCK 
....................    #endif 
.................... //   #define EXT_CAN_RESET   PIN_B5 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX0RTS  PIN_C4 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX1RTS  PIN_B4 //CCS library does not use this pin by default 
.................... //   #define EXT_CAN_TX2RTS  PIN_C2 //CCS library does not use this pin by default 
.................... #endif 
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes MCP2510 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages). 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE, etc) are given a default define in the can-mcp2510.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) 
.................... { 
....................    struct struct_RXB0CTRL b_rxb0ctrl; 
....................     
....................    mcp2510_init(); 
....................     
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01DA:  MOVLW  04
01DB:  MOVWF  3B
01DC:  CALL   0CB
....................    can_set_baud(); 
....................     
....................    memset(&b_rxb0ctrl,0,1); 
*
0212:  MOVLW  20
0213:  MOVWF  05
0214:  MOVLW  1A
0215:  MOVWF  04
0216:  CLRF   20
0217:  MOVLW  01
0218:  MOVWF  21
0219:  CALL   0A4
....................    // b_rxb0ctrl=0; 
....................    b_rxb0ctrl.rxm=CAN_RX_VALID; 
021A:  MOVLW  9F
021B:  ANDWF  3A,W
021C:  MOVWF  3A
....................    b_rxb0ctrl.bukt=CAN_USE_RX_DOUBLE_BUFFER; 
021D:  BSF    3A.2
....................    mcp2510_write(RXB0CTRL, (unsigned int8)b_rxb0ctrl); 
021E:  MOVLW  60
021F:  MOVWF  66
0220:  MOVF   3A,W
0221:  MOVWF  67
0222:  CALL   0AC
....................    mcp2510_write(RXB1CTRL, (unsigned int8)b_rxb0ctrl); 
0223:  MOVLW  70
0224:  MOVWF  66
0225:  MOVF   3A,W
0226:  MOVWF  67
0227:  CALL   0AC
....................  
....................    //if you want to configure the TXnRTS pins, do it here.  default is off 
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 (RX BUFFER 0) 
0228:  MOVLW  23
0229:  MOVWF  3B
022A:  CLRF   3F
022B:  CLRF   3E
022C:  CLRF   3D
022D:  CLRF   3C
022E:  CLRF   40
022F:  CALL   102
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 (RX BUFFER 0) 
0230:  MOVLW  03
0231:  MOVWF  3B
0232:  CLRF   3F
0233:  CLRF   3E
0234:  CLRF   3D
0235:  CLRF   3C
0236:  CLRF   40
0237:  CALL   102
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 (RX BUFFER 0) 
0238:  MOVLW  07
0239:  MOVWF  3B
023A:  CLRF   3F
023B:  CLRF   3E
023C:  CLRF   3D
023D:  CLRF   3C
023E:  CLRF   40
023F:  CALL   102
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 (RX BUFFER 1) 
0240:  MOVLW  27
0241:  MOVWF  3B
0242:  CLRF   3F
0243:  CLRF   3E
0244:  CLRF   3D
0245:  CLRF   3C
0246:  CLRF   40
0247:  CALL   102
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 (RX BUFFER 1) 
0248:  MOVLW  0B
0249:  MOVWF  3B
024A:  CLRF   3F
024B:  CLRF   3E
024C:  CLRF   3D
024D:  CLRF   3C
024E:  CLRF   40
024F:  CALL   102
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 (RX BUFFER 1) 
0250:  MOVLW  13
0251:  MOVWF  3B
0252:  CLRF   3F
0253:  CLRF   3E
0254:  CLRF   3D
0255:  CLRF   3C
0256:  CLRF   40
0257:  CALL   102
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 (RX BUFFER 1) 
0258:  MOVLW  17
0259:  MOVWF  3B
025A:  CLRF   3F
025B:  CLRF   3E
025C:  CLRF   3D
025D:  CLRF   3C
025E:  CLRF   40
025F:  CALL   102
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 (RX BUFFER 1) 
0260:  MOVLW  1B
0261:  MOVWF  3B
0262:  CLRF   3F
0263:  CLRF   3E
0264:  CLRF   3D
0265:  CLRF   3C
0266:  CLRF   40
0267:  CALL   102
....................        
....................    can_set_mode(CAN_OP_NORMAL); 
0268:  CLRF   3B
0269:  CALL   0CB
026A:  MOVLP  00
026B:  GOTO   5C6 (RETURN)
.................... } 
....................  
.................... //caso vazio(0xFF), por padrão a velocidade é 500kbps 
.................... //// CAN Rate     ####################################### 
.................... //// 500Kbps ---- BRP = 0 / PS1  = 1 /  PSG = 1 / PS2 = 2 
.................... //// 250Kbps ---- BRP = 1 / PS1  = 1 /  PSG = 2 / PS2 = 1 
.................... //// 200Kbps ---- BRP = 1 / PS1  = 2 /  PSG = 2 / PS2 = 2 
.................... //// 125Kbps ---- BRP = 1 / PS1  = 5 /  PSG = 5 / PS2 = 2 
.................... //// 80Kbps ----- BRP = 4 / PS1  = 2 /  PSG = 2 / PS2 = 2 
.................... //// 50Kbps ----- BRP = 4 / PS1  = 5 /  PSG = 2 / PS2 = 5 
.................... ////              ####################################### 
.................... void set_freq_var(int8 freq) 
.................... { 
....................    switch(freq) 
....................    { 
....................       case 0x00: //500kbps (PADRÃO) 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 1; 
....................          CAN_BRG_PROPAGATION_TIME = 1; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x01: //250kbps 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 4; 
....................          CAN_BRG_PROPAGATION_TIME = 3; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 5; 
....................          break; 
....................           
....................       case 0x02: //200kbps 
....................          CAN_BRG_PRESCALAR = 1; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 2; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x03: //125kbps 
....................          CAN_BRG_PRESCALAR = 1; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 5; 
....................          CAN_BRG_PROPAGATION_TIME = 5; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x04: //80kbps 
....................          CAN_BRG_PRESCALAR = 4; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 2; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2; 
....................          break; 
....................           
....................       case 0x5: //50kbps 
....................          CAN_BRG_PRESCALAR = 4; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 5; 
....................          CAN_BRG_PROPAGATION_TIME = 2; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 5; 
....................          break; 
....................           
....................       default: //500kbps 
....................          CAN_BRG_PRESCALAR = 0; 
....................          CAN_BRG_PHASE_SEGMENT_1 = 1; 
....................          CAN_BRG_PROPAGATION_TIME = 1; 
....................          CAN_BRG_PHASE_SEGMENT_2 = 2;  
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-mcp2510.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with CCS's CAN Prototype board and 
.................... // Microchip's MCP250xxx CAN Developers Kit if this PIC is running at 8Mhz. 
.................... //   Paramaters: 
.................... //     freq - caso seja 0, seta baud padrão de 500kbps. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud()  
.................... { 
....................    struct struct_CNF1 new_CNF1; 
....................    struct struct_CNF2 new_CNF2; 
....................    struct struct_CNF3 new_CNF3; 
....................  
....................     
....................    new_CNF1.brp=CAN_BRG_PRESCALAR; 
*
01DD:  MOVF   28,W
01DE:  ANDLW  3F
01DF:  MOVWF  20
01E0:  MOVLW  C0
01E1:  ANDWF  3B,W
01E2:  IORWF  20,W
01E3:  MOVWF  3B
....................    new_CNF1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01E4:  MOVLW  3F
01E5:  ANDWF  3B,W
01E6:  MOVWF  3B
....................  
....................    new_CNF2.prseg=CAN_BRG_PROPAGATION_TIME; 
01E7:  MOVF   2A,W
01E8:  ANDLW  07
01E9:  MOVWF  20
01EA:  MOVLW  F8
01EB:  ANDWF  3C,W
01EC:  IORWF  20,W
01ED:  MOVWF  3C
....................    new_CNF2.phseg1=CAN_BRG_PHASE_SEGMENT_1; 
01EE:  MOVF   29,W
01EF:  ANDLW  07
01F0:  MOVWF  20
01F1:  LSLF   20,F
01F2:  RLF    20,F
01F3:  RLF    20,F
01F4:  MOVLW  C7
01F5:  ANDWF  3C,W
01F6:  IORWF  20,W
01F7:  MOVWF  3C
....................    new_CNF2.sam=CAN_BRG_SAM; 
01F8:  BCF    3C.6
....................    new_CNF2.btlmode=CAN_BRG_SEG_2_PHASE_TS; 
01F9:  BSF    3C.7
....................  
....................    new_CNF3.phseg2=CAN_BRG_PHASE_SEGMENT_2; 
01FA:  MOVF   2B,W
01FB:  ANDLW  07
01FC:  MOVWF  20
01FD:  MOVLW  F8
01FE:  ANDWF  3D,W
01FF:  IORWF  20,W
0200:  MOVWF  3D
....................    new_CNF3.wakfil=CAN_BRG_WAKE_FILTER; 
0201:  BCF    3D.6
....................    new_CNF3.sof=0; 
0202:  BCF    3D.7
....................  
....................    mcp2510_write(CNF1, (unsigned int8)new_CNF1); 
0203:  MOVLW  2A
0204:  MOVWF  66
0205:  MOVF   3B,W
0206:  MOVWF  67
0207:  CALL   0AC
....................    mcp2510_write(CNF2, (unsigned int8)new_CNF2); 
0208:  MOVLW  29
0209:  MOVWF  66
020A:  MOVF   3C,W
020B:  MOVWF  67
020C:  CALL   0AC
....................    mcp2510_write(CNF3, (unsigned int8)new_CNF3); 
020D:  MOVLW  28
020E:  MOVWF  66
020F:  MOVF   3D,W
0210:  MOVWF  67
0211:  CALL   0AC
....................  
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG1); 
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG2); 
.................... //!   mcp2510_write(CNF1, MCP_8MHz_250kBPS_CFG3); 
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) 
.................... { 
....................    struct struct_CANCTRL old_CANCTRL; 
....................    struct struct_CANSTAT new_CANSTAT; 
....................                                                         
....................    memset(&old_CANCTRL,mcp2510_read(CANCTRL),1); 
*
00CB:  MOVLW  0F
00CC:  MOVLB  01
00CD:  MOVWF  25
00CE:  MOVLB  00
00CF:  CALL   081
00D0:  MOVF   21,W
00D1:  MOVWF  3E
00D2:  MOVLW  20
00D3:  MOVWF  05
00D4:  MOVLW  1C
00D5:  MOVWF  04
00D6:  MOVF   21,W
00D7:  MOVWF  20
00D8:  MOVLW  01
00D9:  MOVWF  21
00DA:  CALL   0A4
....................    //old_CANCTRL=mcp2510_read(CANCTRL); 
....................     
....................    old_CANCTRL.reqop=mode; 
00DB:  SWAPF  3B,W
00DC:  ANDLW  70
00DD:  MOVWF  20
00DE:  LSLF   20,F
00DF:  MOVLW  1F
00E0:  ANDWF  3C,W
00E1:  IORWF  20,W
00E2:  MOVWF  3C
....................    old_CANCTRL.osm=1;//one shot mode 
00E3:  BSF    3C.3
....................  
....................    mcp2510_write(CANCTRL, (unsigned int8)old_CANCTRL); 
00E4:  MOVLW  0F
00E5:  MOVWF  66
00E6:  MOVF   3C,W
00E7:  MOVWF  67
00E8:  CALL   0AC
....................  
....................    do 
....................    { 
....................       memset(&new_CANSTAT,mcp2510_read(CANSTAT),1); 
00E9:  MOVLW  0E
00EA:  MOVLB  01
00EB:  MOVWF  25
00EC:  MOVLB  00
00ED:  CALL   081
00EE:  MOVF   21,W
00EF:  MOVWF  3E
00F0:  MOVLW  20
00F1:  MOVWF  05
00F2:  MOVLW  1D
00F3:  MOVWF  04
00F4:  MOVF   21,W
00F5:  MOVWF  20
00F6:  MOVLW  01
00F7:  MOVWF  21
00F8:  CALL   0A4
....................       //old_CANCTRL=mcp2510_read(CANCTRL);      
....................    } while (new_CANSTAT.opmode != mode); 
00F9:  MOVF   3D,W
00FA:  MOVWF  20
00FB:  SWAPF  20,F
00FC:  LSRF   20,W
00FD:  ANDLW  07
00FE:  SUBWF  3B,W
00FF:  BTFSS  03.2
0100:  GOTO   0E9
0101:  RETURN
....................   
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int8 addr, unsigned int32 id, int1 ext) 
.................... { 
....................    unsigned int8 converted_id[4]; 
....................    unsigned int8 *ptr; 
....................  
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh 
0102:  MOVLW  20
0103:  MOVWF  46
0104:  MOVLW  24
0105:  MOVWF  45
....................  
....................    if (ext) 
0106:  MOVF   40,F
0107:  BTFSC  03.2
0108:  GOTO   15B
....................    {  //extended 
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0109:  MOVF   45,W
010A:  MOVWF  04
010B:  MOVF   46,W
010C:  MOVWF  05
010D:  MOVF   3C,W
010E:  MOVWF  00
....................  
....................       //eidh 
....................       ptr--; 
010F:  MOVF   45,W
0110:  BTFSC  03.2
0111:  DECF   46,F
0112:  DECF   45,F
....................       *ptr=make8(id,1); //8:15 
0113:  MOVF   45,W
0114:  MOVWF  04
0115:  MOVF   46,W
0116:  MOVWF  05
0117:  MOVF   3D,W
0118:  MOVWF  00
....................  
....................       //sidl 
....................       ptr--; 
0119:  MOVF   45,W
011A:  BTFSC  03.2
011B:  DECF   46,F
011C:  DECF   45,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
011D:  MOVF   45,W
011E:  MOVWF  04
011F:  MOVF   46,W
0120:  MOVWF  05
0121:  MOVF   3E,W
0122:  ANDLW  03
0123:  MOVWF  00
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
0124:  MOVF   45,W
0125:  MOVWF  04
0126:  MOVF   46,W
0127:  MOVWF  05
0128:  MOVF   3E,W
0129:  MOVWF  20
012A:  RLF    20,F
012B:  RLF    20,F
012C:  RLF    20,F
012D:  MOVLW  F8
012E:  ANDWF  20,F
012F:  MOVF   20,W
0130:  ANDLW  E0
0131:  IORWF  00,W
0132:  MOVWF  00
....................       *ptr|=0x08; 
0133:  MOVF   45,W
0134:  MOVWF  04
0135:  MOVF   46,W
0136:  MOVWF  05
0137:  MOVF   00,W
0138:  IORLW  08
0139:  MOVWF  00
....................  
....................  
....................       //sidh 
....................       ptr--; 
013A:  MOVF   45,W
013B:  BTFSC  03.2
013C:  DECF   46,F
013D:  DECF   45,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
013E:  MOVF   45,W
013F:  MOVWF  04
0140:  MOVF   46,W
0141:  MOVWF  05
0142:  MOVF   3E,W
0143:  MOVWF  20
0144:  SWAPF  20,F
0145:  RRF    20,F
0146:  MOVLW  07
0147:  ANDWF  20,F
0148:  MOVF   20,W
0149:  ANDLW  07
014A:  MOVWF  00
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
014B:  MOVF   45,W
014C:  MOVWF  04
014D:  MOVF   46,W
014E:  MOVWF  05
014F:  MOVF   3F,W
0150:  MOVWF  20
0151:  RLF    20,F
0152:  RLF    20,F
0153:  RLF    20,F
0154:  MOVLW  F8
0155:  ANDWF  20,F
0156:  MOVF   20,W
0157:  ANDLW  F8
0158:  IORWF  00,W
0159:  MOVWF  00
....................    } 
015A:  GOTO   19A
....................    else  
....................    {   //standard 
....................       //eidl 
....................       *ptr=0; 
015B:  MOVF   45,W
015C:  MOVWF  04
015D:  MOVF   46,W
015E:  MOVWF  05
015F:  CLRF   00
....................  
....................       //eidh 
....................       ptr--; 
0160:  MOVF   45,W
0161:  BTFSC  03.2
0162:  DECF   46,F
0163:  DECF   45,F
....................       *ptr=0; 
0164:  MOVF   45,W
0165:  MOVWF  04
0166:  MOVF   46,W
0167:  MOVWF  05
0168:  CLRF   00
....................  
....................       //sidl 
....................       ptr--; 
0169:  MOVF   45,W
016A:  BTFSC  03.2
016B:  DECF   46,F
016C:  DECF   45,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
016D:  MOVF   45,W
016E:  MOVWF  04
016F:  MOVF   46,W
0170:  MOVWF  05
0171:  MOVF   3C,W
0172:  MOVWF  20
0173:  SWAPF  20,F
0174:  RLF    20,F
0175:  MOVLW  E0
0176:  ANDWF  20,F
0177:  MOVF   20,W
0178:  ANDLW  E0
0179:  MOVWF  00
....................  
....................       //sidh 
....................       ptr--; 
017A:  MOVF   45,W
017B:  BTFSC  03.2
017C:  DECF   46,F
017D:  DECF   45,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
017E:  MOVF   45,W
017F:  MOVWF  04
0180:  MOVF   46,W
0181:  MOVWF  05
0182:  MOVF   3C,W
0183:  MOVWF  20
0184:  RRF    20,F
0185:  RRF    20,F
0186:  RRF    20,F
0187:  MOVLW  1F
0188:  ANDWF  20,F
0189:  MOVF   20,W
018A:  ANDLW  1F
018B:  MOVWF  00
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
018C:  MOVF   45,W
018D:  MOVWF  04
018E:  MOVF   46,W
018F:  MOVWF  05
0190:  MOVF   3D,W
0191:  MOVWF  20
0192:  SWAPF  20,F
0193:  RLF    20,F
0194:  MOVLW  E0
0195:  ANDWF  20,F
0196:  MOVF   20,W
0197:  ANDLW  E0
0198:  IORWF  00,W
0199:  MOVWF  00
....................    } 
....................  
....................    //0=eidl, 1=eidh, 2=sidl, 3=sidh 
....................    mcp2510_write(addr--, converted_id[3]); 
019A:  MOVF   3B,W
019B:  DECF   3B,F
019C:  MOVWF  47
019D:  MOVWF  66
019E:  MOVF   44,W
019F:  MOVWF  67
01A0:  CALL   0AC
....................    mcp2510_write(addr--, converted_id[2]); 
01A1:  MOVF   3B,W
01A2:  DECF   3B,F
01A3:  MOVWF  47
01A4:  MOVWF  66
01A5:  MOVF   43,W
01A6:  MOVWF  67
01A7:  CALL   0AC
....................    mcp2510_write(addr--, converted_id[1]); 
01A8:  MOVF   3B,W
01A9:  DECF   3B,F
01AA:  MOVWF  47
01AB:  MOVWF  66
01AC:  MOVF   42,W
01AD:  MOVWF  67
01AE:  CALL   0AC
....................    mcp2510_write(addr, converted_id[0]); 
01AF:  MOVF   3B,W
01B0:  MOVWF  66
01B1:  MOVF   41,W
01B2:  MOVWF  67
01B3:  CALL   0AC
01B4:  RETURN
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int8 addr, int1 ext) 
.................... { 
....................    unsigned int32 ret; 
....................    unsigned int8 * ptr; 
....................    unsigned int8 converted_id[4]; 
....................  
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh 
*
03A2:  MOVLW  20
03A3:  MOVWF  6F
03A4:  MOVLW  53
03A5:  MOVWF  6E
....................  
....................    converted_id[3]=mcp2510_read(addr--); 
03A6:  MOVF   68,W
03A7:  DECF   68,F
03A8:  MOVLB  01
03A9:  MOVWF  24
03AA:  MOVWF  25
03AB:  MOVLB  00
03AC:  CALL   081
03AD:  MOVF   21,W
03AE:  MOVLB  01
03AF:  MOVWF  23
....................    converted_id[2]=mcp2510_read(addr--); 
03B0:  MOVLB  00
03B1:  MOVF   68,W
03B2:  DECF   68,F
03B3:  MOVLB  01
03B4:  MOVWF  24
03B5:  MOVWF  25
03B6:  MOVLB  00
03B7:  CALL   081
03B8:  MOVF   21,W
03B9:  MOVLB  01
03BA:  MOVWF  22
....................    converted_id[1]=mcp2510_read(addr--); 
03BB:  MOVLB  00
03BC:  MOVF   68,W
03BD:  DECF   68,F
03BE:  MOVLB  01
03BF:  MOVWF  24
03C0:  MOVWF  25
03C1:  MOVLB  00
03C2:  CALL   081
03C3:  MOVF   21,W
03C4:  MOVLB  01
03C5:  MOVWF  21
....................    converted_id[0]=mcp2510_read(addr); 
03C6:  MOVLB  00
03C7:  MOVF   68,W
03C8:  MOVLB  01
03C9:  MOVWF  25
03CA:  MOVLB  00
03CB:  CALL   081
03CC:  MOVF   21,W
03CD:  MOVLB  01
03CE:  MOVWF  20
....................  
....................    ret=0; 
03CF:  MOVLB  00
03D0:  CLRF   6D
03D1:  CLRF   6C
03D2:  CLRF   6B
03D3:  CLRF   6A
....................  
....................  
....................    if (ext) 
03D4:  MOVF   69,F
03D5:  BTFSC  03.2
03D6:  GOTO   485
....................    { 
....................       ret=(unsigned int32)*ptr;  //eidl 
03D7:  MOVF   6E,W
03D8:  MOVWF  04
03D9:  MOVF   6F,W
03DA:  MOVWF  05
03DB:  MOVF   00,W
03DC:  CLRF   6D
03DD:  CLRF   6C
03DE:  CLRF   6B
03DF:  MOVWF  6A
....................  
....................       ptr--;     //eidh 
03E0:  MOVF   6E,W
03E1:  BTFSC  03.2
03E2:  DECF   6F,F
03E3:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 8); 
03E4:  MOVF   6E,W
03E5:  MOVWF  04
03E6:  MOVF   6F,W
03E7:  MOVWF  05
03E8:  MOVF   00,W
03E9:  MOVLB  01
03EA:  CLRF   27
03EB:  CLRF   26
03EC:  CLRF   25
03ED:  MOVWF  24
03EE:  MOVF   26,W
03EF:  MOVLB  00
03F0:  MOVWF  23
03F1:  MOVLB  01
03F2:  MOVF   25,W
03F3:  MOVLB  00
03F4:  MOVWF  22
03F5:  MOVLB  01
03F6:  MOVF   24,W
03F7:  MOVLB  00
03F8:  MOVWF  21
03F9:  CLRF   20
03FA:  MOVF   20,W
03FB:  IORWF  6A,F
03FC:  MOVF   21,W
03FD:  IORWF  6B,F
03FE:  MOVF   22,W
03FF:  IORWF  6C,F
0400:  MOVF   23,W
0401:  IORWF  6D,F
....................  
....................       ptr--;     //sidl 
0402:  MOVF   6E,W
0403:  BTFSC  03.2
0404:  DECF   6F,F
0405:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
0406:  MOVF   6E,W
0407:  MOVWF  04
0408:  MOVF   6F,W
0409:  MOVWF  05
040A:  MOVF   00,W
040B:  MOVLB  01
040C:  CLRF   27
040D:  CLRF   26
040E:  CLRF   25
040F:  MOVWF  24
0410:  MOVLW  03
0411:  ANDWF  24,F
0412:  CLRF   25
0413:  CLRF   26
0414:  CLRF   27
0415:  MOVF   25,W
0416:  MOVLB  00
0417:  MOVWF  23
0418:  MOVLB  01
0419:  MOVF   24,W
041A:  MOVLB  00
041B:  MOVWF  22
041C:  CLRF   20
041D:  CLRF   21
041E:  MOVF   20,W
041F:  IORWF  6A,F
0420:  MOVF   21,W
0421:  IORWF  6B,F
0422:  MOVF   22,W
0423:  IORWF  6C,F
0424:  MOVF   23,W
0425:  IORWF  6D,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
0426:  MOVF   6E,W
0427:  MOVWF  04
0428:  MOVF   6F,W
0429:  MOVWF  05
042A:  MOVF   00,W
042B:  MOVLB  01
042C:  CLRF   27
042D:  CLRF   26
042E:  CLRF   25
042F:  MOVWF  24
0430:  MOVLW  E0
0431:  ANDWF  24,F
0432:  CLRF   25
0433:  CLRF   26
0434:  CLRF   27
0435:  MOVLB  00
0436:  CLRF   20
0437:  MOVLB  01
0438:  RLF    24,W
0439:  MOVLB  00
043A:  MOVWF  21
043B:  MOVLB  01
043C:  RLF    25,W
043D:  MOVLB  00
043E:  MOVWF  22
043F:  MOVLB  01
0440:  RLF    26,W
0441:  MOVLB  00
0442:  MOVWF  23
0443:  RLF    21,F
0444:  RLF    22,F
0445:  RLF    23,F
0446:  RLF    21,F
0447:  RLF    22,F
0448:  RLF    23,F
0449:  RLF    21,F
044A:  RLF    22,F
044B:  RLF    23,F
044C:  RLF    21,F
044D:  RLF    22,F
044E:  RLF    23,F
044F:  MOVLW  E0
0450:  ANDWF  21,F
0451:  MOVF   20,W
0452:  IORWF  6A,F
0453:  MOVF   21,W
0454:  IORWF  6B,F
0455:  MOVF   22,W
0456:  IORWF  6C,F
0457:  MOVF   23,W
0458:  IORWF  6D,F
....................  
....................       ptr--;     //sidh 
0459:  MOVF   6E,W
045A:  BTFSC  03.2
045B:  DECF   6F,F
045C:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 21); 
045D:  MOVF   6E,W
045E:  MOVWF  04
045F:  MOVF   6F,W
0460:  MOVWF  05
0461:  MOVF   00,W
0462:  MOVLB  01
0463:  CLRF   27
0464:  CLRF   26
0465:  CLRF   25
0466:  MOVWF  24
0467:  MOVLB  00
0468:  CLRF   20
0469:  CLRF   21
046A:  MOVLB  01
046B:  RLF    24,W
046C:  MOVLB  00
046D:  MOVWF  22
046E:  MOVLB  01
046F:  RLF    25,W
0470:  MOVLB  00
0471:  MOVWF  23
0472:  RLF    22,F
0473:  RLF    23,F
0474:  RLF    22,F
0475:  RLF    23,F
0476:  RLF    22,F
0477:  RLF    23,F
0478:  RLF    22,F
0479:  RLF    23,F
047A:  MOVLW  E0
047B:  ANDWF  22,F
047C:  MOVF   20,W
047D:  IORWF  6A,F
047E:  MOVF   21,W
047F:  IORWF  6B,F
0480:  MOVF   22,W
0481:  IORWF  6C,F
0482:  MOVF   23,W
0483:  IORWF  6D,F
....................    } 
0484:  GOTO   4E8
....................    else 
....................    { 
....................       ptr-=2;    //sidl 
0485:  MOVLW  02
0486:  SUBWF  6E,F
0487:  MOVLW  00
0488:  SUBWFC 6F,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
0489:  MOVF   6E,W
048A:  MOVWF  04
048B:  MOVF   6F,W
048C:  MOVWF  05
048D:  MOVF   00,W
048E:  MOVLB  01
048F:  CLRF   27
0490:  CLRF   26
0491:  CLRF   25
0492:  MOVWF  24
0493:  MOVLW  E0
0494:  ANDWF  24,F
0495:  CLRF   25
0496:  CLRF   26
0497:  CLRF   27
0498:  RRF    27,W
0499:  MOVLB  00
049A:  MOVWF  6D
049B:  MOVLB  01
049C:  RRF    26,W
049D:  MOVLB  00
049E:  MOVWF  6C
049F:  MOVLB  01
04A0:  RRF    25,W
04A1:  MOVLB  00
04A2:  MOVWF  6B
04A3:  MOVLB  01
04A4:  RRF    24,W
04A5:  MOVLB  00
04A6:  MOVWF  6A
04A7:  RRF    6D,F
04A8:  RRF    6C,F
04A9:  RRF    6B,F
04AA:  RRF    6A,F
04AB:  RRF    6D,F
04AC:  RRF    6C,F
04AD:  RRF    6B,F
04AE:  RRF    6A,F
04AF:  RRF    6D,F
04B0:  RRF    6C,F
04B1:  RRF    6B,F
04B2:  RRF    6A,F
04B3:  RRF    6D,F
04B4:  RRF    6C,F
04B5:  RRF    6B,F
04B6:  RRF    6A,F
04B7:  MOVLW  07
04B8:  ANDWF  6D,F
....................  
....................       ptr--;     //sidh 
04B9:  MOVF   6E,W
04BA:  BTFSC  03.2
04BB:  DECF   6F,F
04BC:  DECF   6E,F
....................       ret|=((unsigned int32)*ptr << 3); 
04BD:  MOVF   6E,W
04BE:  MOVWF  04
04BF:  MOVF   6F,W
04C0:  MOVWF  05
04C1:  MOVF   00,W
04C2:  MOVLB  01
04C3:  CLRF   27
04C4:  CLRF   26
04C5:  CLRF   25
04C6:  MOVWF  24
04C7:  RLF    24,W
04C8:  MOVLB  00
04C9:  MOVWF  20
04CA:  MOVLB  01
04CB:  RLF    25,W
04CC:  MOVLB  00
04CD:  MOVWF  21
04CE:  MOVLB  01
04CF:  RLF    26,W
04D0:  MOVLB  00
04D1:  MOVWF  22
04D2:  MOVLB  01
04D3:  RLF    27,W
04D4:  MOVLB  00
04D5:  MOVWF  23
04D6:  RLF    20,F
04D7:  RLF    21,F
04D8:  RLF    22,F
04D9:  RLF    23,F
04DA:  RLF    20,F
04DB:  RLF    21,F
04DC:  RLF    22,F
04DD:  RLF    23,F
04DE:  MOVLW  F8
04DF:  ANDWF  20,F
04E0:  MOVF   20,W
04E1:  IORWF  6A,F
04E2:  MOVF   21,W
04E3:  IORWF  6B,F
04E4:  MOVF   22,W
04E5:  IORWF  6C,F
04E6:  MOVF   23,W
04E7:  IORWF  6D,F
....................    } 
....................  
....................    return(ret); 
04E8:  MOVF   6A,W
04E9:  MOVWF  20
04EA:  MOVF   6B,W
04EB:  MOVWF  21
04EC:  MOVF   6C,W
04ED:  MOVWF  22
04EE:  MOVF   6D,W
04EF:  MOVWF  23
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int8 * data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 port; 
....................  
....................    unsigned int8 TXRXBaD0; 
....................    unsigned int8 TXBaCTRL; 
....................    unsigned int8 TXRXBaEIDL; 
....................    unsigned int8 TXBaDLC; 
....................  
....................    struct txbNctrl_struct b_TXBaCTRL; 
....................    struct rxbNdlc_struct b_TXBaDLC; 
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL; 
....................  
....................    //b_TXB0CTRL=mcp2510_read(TXB0CTRL); 
....................    memset(&b_TXB0CTRL,mcp2510_read(TXB0CTRL),1); 
....................    //b_TXB1CTRL=mcp2510_read(TXB1CTRL); 
....................    memset(&b_TXB1CTRL,mcp2510_read(TXB1CTRL),1); 
....................    //b_TXB2CTRL=mcp2510_read(TXB2CTRL); 
....................    memset(&b_TXB2CTRL,mcp2510_read(TXB2CTRL),1); 
....................     
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!b_TXB0CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB0D0; 
....................       TXBaCTRL=TXB0CTRL; 
....................       TXRXBaEIDL=TXB0EIDL; 
....................       TXBaDLC=TXB0DLC; 
....................       port=0; 
....................    } 
....................    else if (!b_TXB1CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB1D0; 
....................       TXBaCTRL=TXB1CTRL; 
....................       TXRXBaEIDL=TXB1EIDL; 
....................       TXBaDLC=TXB1DLC; 
....................       port=1; 
....................    } 
....................    else if (!b_TXB2CTRL.txreq) 
....................    { 
....................       TXRXBaD0=TXB2D0; 
....................       TXBaCTRL=TXB2CTRL; 
....................       TXRXBaEIDL=TXB2EIDL; 
....................       TXBaDLC=TXB2DLC; 
....................       port=2; 
....................    } 
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
....................    } 
....................     
....................     
....................     
....................    //set priority. 
....................    //b_TXBaCTRL=mcp2510_read(TXBaCTRL); 
....................    memset(&b_TXBaCTRL,mcp2510_read(TXBaCTRL),1); 
....................     
....................    b_TXBaCTRL.txpri=priority; 
....................    mcp2510_write(TXBaCTRL, (unsigned int8)b_TXBaCTRL); 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaEIDL, id, ext); 
....................  
....................    //set tx data count 
....................    //b_TXBaDLC=len; 
....................    memset(&b_TXBaDLC,len,1); 
....................    b_TXBaDLC.rtr=rtr; 
....................    mcp2510_write(TXBaDLC, (unsigned int8)b_TXBaDLC); 
....................  
....................    //write to buffer 
....................     for (i=TXRXBaD0; i<(TXRXBaD0 + len); i++) 
....................     { 
....................       mcp2510_write(i,*data); 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    //b_TXBaCTRL=mcp2510_read(TXBaCTRL); 
....................    memset(&b_TXBaCTRL,mcp2510_read(TXBaCTRL),1); 
....................    b_TXBaCTRL.txreq=1; 
....................    mcp2510_write(TXBaCTRL, (unsigned int8)b_TXBaCTRL); 
....................     
....................     
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) 
....................             { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) 
....................                { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int8 * data, unsigned int8 & len, struct rx_stat & stat) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    struct struct_RXB0CTRL b_RXB0CTRL; 
....................    struct struct_RXB1CTRL b_RXB1CTRL; 
....................    struct struct_EFLG b_EFLG; 
....................  
....................    unsigned int8 RXBaDLC; 
....................    struct rxbNdlc_struct b_RXBaDLC; 
....................  
....................    unsigned int8 TXRXBaSIDL; 
....................    struct struct_TXRXBaSIDL b_TXRXBaSIDL; 
....................  
....................  
....................    unsigned int8 RXBaD0; 
....................    struct struct_CANINTF b_CANINTF; 
....................  
....................    //b_CANINTF=mcp2510_read(CANINTF); 
....................    memset(&b_CANINTF,mcp2510_read(CANINTF),1); 
*
02F0:  MOVLW  2C
02F1:  MOVLB  01
02F2:  MOVWF  25
02F3:  MOVLB  00
02F4:  CALL   081
02F5:  MOVF   21,W
02F6:  MOVWF  60
02F7:  MOVLW  20
02F8:  MOVWF  05
02F9:  MOVLW  3F
02FA:  MOVWF  04
02FB:  MOVF   21,W
02FC:  MOVWF  20
02FD:  MOVLW  01
02FE:  MOVWF  21
02FF:  CALL   0A4
....................    //b_RXB0CTRL=mcp2510_read(RXB0CTRL); 
....................    memset(&b_RXB0CTRL,mcp2510_read(RXB0CTRL),1); 
0300:  MOVLW  60
0301:  MOVLB  01
0302:  MOVWF  25
0303:  MOVLB  00
0304:  CALL   081
0305:  MOVF   21,W
0306:  MOVWF  60
0307:  MOVLW  20
0308:  MOVWF  05
0309:  MOVLW  37
030A:  MOVWF  04
030B:  MOVF   21,W
030C:  MOVWF  20
030D:  MOVLW  01
030E:  MOVWF  21
030F:  CALL   0A4
....................    //b_RXB1CTRL=mcp2510_read(RXB1CTRL); 
....................    memset(&b_RXB1CTRL,mcp2510_read(RXB1CTRL),1); 
0310:  MOVLW  70
0311:  MOVLB  01
0312:  MOVWF  25
0313:  MOVLB  00
0314:  CALL   081
0315:  MOVF   21,W
0316:  MOVWF  60
0317:  MOVLW  20
0318:  MOVWF  05
0319:  MOVLW  38
031A:  MOVWF  04
031B:  MOVF   21,W
031C:  MOVWF  20
031D:  MOVLW  01
031E:  MOVWF  21
031F:  CALL   0A4
....................    //b_EFLG=mcp2510_read(EFLG); 
....................    memset(&b_EFLG,mcp2510_read(EFLG),1); 
0320:  MOVLW  2D
0321:  MOVLB  01
0322:  MOVWF  25
0323:  MOVLB  00
0324:  CALL   081
0325:  MOVF   21,W
0326:  MOVWF  60
0327:  MOVLW  20
0328:  MOVWF  05
0329:  MOVLW  39
032A:  MOVWF  04
032B:  MOVF   21,W
032C:  MOVWF  20
032D:  MOVLW  01
032E:  MOVWF  21
032F:  CALL   0A4
....................  
....................     if (b_CANINTF.rx0if) 
0330:  BTFSS  5F.0
0331:  GOTO   34F
....................     { 
....................         stat.buffer=0; 
0332:  BCF    3A.4
....................  
....................         stat.err_ovfl=b_EFLG.rx0ovr; 
0333:  BCF    3A.0
0334:  BTFSC  59.6
0335:  BSF    3A.0
....................         b_EFLG.rx0ovr=0; 
0336:  BCF    59.6
....................         mcp2510_write(EFLG, (unsigned int8)b_EFLG); 
0337:  MOVLW  2D
0338:  MOVWF  66
0339:  MOVF   59,W
033A:  MOVWF  67
033B:  CALL   0AC
....................  
....................         if (b_RXB0CTRL.bukt) 
033C:  BTFSS  57.2
033D:  GOTO   348
....................         { 
....................          stat.filthit=b_RXB0CTRL.filhit0; 
033E:  MOVLW  00
033F:  BTFSC  57.0
0340:  MOVLW  01
0341:  ANDLW  07
0342:  MOVWF  20
0343:  LSLF   20,F
0344:  MOVLW  F1
0345:  ANDWF  3A,W
0346:  IORWF  20,W
0347:  MOVWF  3A
....................         } 
....................  
....................         RXBaDLC=RXB0DLC; 
0348:  MOVLW  65
0349:  MOVWF  5A
....................         TXRXBaSIDL=RXB0SIDL; 
034A:  MOVLW  62
034B:  MOVWF  5C
....................         RXBaD0=RXB0D0; 
034C:  MOVLW  66
034D:  MOVWF  5E
....................     } 
034E:  GOTO   36E
....................     else if (b_CANINTF.rx1if) 
034F:  BTFSS  5F.1
0350:  GOTO   36B
....................     { 
....................         stat.buffer=1; 
0351:  BSF    3A.4
....................  
....................         stat.err_ovfl=b_EFLG.rx1ovr; 
0352:  BCF    3A.0
0353:  BTFSC  59.7
0354:  BSF    3A.0
....................         b_EFLG.rx1ovr=0; 
0355:  BCF    59.7
....................         mcp2510_write(EFLG, (unsigned int8)b_EFLG); 
0356:  MOVLW  2D
0357:  MOVWF  66
0358:  MOVF   59,W
0359:  MOVWF  67
035A:  CALL   0AC
....................  
....................         stat.filthit=b_RXB1CTRL.filhit0; 
035B:  MOVF   58,W
035C:  ANDLW  07
035D:  ANDLW  07
035E:  MOVWF  20
035F:  LSLF   20,F
0360:  MOVLW  F1
0361:  ANDWF  3A,W
0362:  IORWF  20,W
0363:  MOVWF  3A
....................         RXBaDLC=RXB1DLC; 
0364:  MOVLW  75
0365:  MOVWF  5A
....................         TXRXBaSIDL=RXB1SIDL; 
0366:  MOVLW  72
0367:  MOVWF  5C
....................         RXBaD0=RXB1D0; 
0368:  MOVLW  76
0369:  MOVWF  5E
....................     } 
036A:  GOTO   36E
....................     else 
....................     { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
036B:  MOVLW  00
036C:  MOVWF  21
036D:  GOTO   526
....................     } 
....................  
....................    //get count 
....................     //b_RXBaDLC=mcp2510_read(RXBaDLC); 
....................     memset(&b_RXBaDLC,mcp2510_read(RXBaDLC),1); 
036E:  MOVF   5A,W
036F:  MOVLB  01
0370:  MOVWF  25
0371:  MOVLB  00
0372:  CALL   081
0373:  MOVF   21,W
0374:  MOVWF  60
0375:  MOVLW  20
0376:  MOVWF  05
0377:  MOVLW  3B
0378:  MOVWF  04
0379:  MOVF   21,W
037A:  MOVWF  20
037B:  MOVLW  01
037C:  MOVWF  21
037D:  CALL   0A4
....................     len = b_RXBaDLC.dlc; 
037E:  MOVF   5B,W
037F:  ANDLW  0F
0380:  MOVWF  3F
....................     stat.rtr=b_RXBaDLC.rtr; 
0381:  BCF    3A.5
0382:  BTFSC  5B.6
0383:  BSF    3A.5
....................  
....................    //was it extended or standard? 
....................     //b_TXRXBaSIDL=mcp2510_read(TXRXBaSIDL); 
....................     memset(&b_TXRXBaSIDL,mcp2510_read(TXRXBaSIDL),1); 
0384:  MOVF   5C,W
0385:  MOVLB  01
0386:  MOVWF  25
0387:  MOVLB  00
0388:  CALL   081
0389:  MOVF   21,W
038A:  MOVWF  60
038B:  MOVLW  20
038C:  MOVWF  05
038D:  MOVLW  3D
038E:  MOVWF  04
038F:  MOVF   21,W
0390:  MOVWF  20
0391:  MOVLW  01
0392:  MOVWF  21
0393:  CALL   0A4
....................     stat.ext=b_TXRXBaSIDL.ext; 
0394:  BCF    3A.6
0395:  BTFSC  5D.3
0396:  BSF    3A.6
....................     id=can_get_id(TXRXBaSIDL + 2,stat.ext); 
0397:  MOVLW  02
0398:  ADDWF  5C,W
0399:  MOVWF  60
039A:  MOVLW  00
039B:  BTFSC  3A.6
039C:  MOVLW  01
039D:  MOVWF  61
039E:  MOVF   60,W
039F:  MOVWF  68
03A0:  MOVF   61,W
03A1:  MOVWF  69
*
04F0:  MOVF   23,W
04F1:  MOVWF  43
04F2:  MOVF   22,W
04F3:  MOVWF  42
04F4:  MOVF   21,W
04F5:  MOVWF  41
04F6:  MOVF   20,W
04F7:  MOVWF  40
....................  
....................    //get data 
....................     for ( i = RXBaD0; i < (RXBaD0 + len); i++ ) 
04F8:  MOVF   5E,W
04F9:  MOVWF  56
04FA:  MOVF   3F,W
04FB:  ADDWF  5E,W
04FC:  SUBWF  56,W
04FD:  BTFSC  03.0
04FE:  GOTO   515
....................     { 
....................         *data=mcp2510_read(i); 
04FF:  MOVF   55,W
0500:  MOVWF  23
0501:  MOVF   54,W
0502:  MOVWF  60
0503:  MOVF   55,W
0504:  MOVWF  61
0505:  MOVF   56,W
0506:  MOVLB  01
0507:  MOVWF  25
0508:  MOVLB  00
0509:  CALL   081
050A:  MOVF   61,W
050B:  MOVWF  05
050C:  MOVF   60,W
050D:  MOVWF  04
050E:  MOVF   21,W
050F:  MOVWF  00
....................         data++; 
0510:  INCF   54,F
0511:  BTFSC  03.2
0512:  INCF   55,F
0513:  INCF   56,F
0514:  GOTO   4FA
....................     } 
....................  
....................     stat.inv=b_CANINTF.merrf; 
0515:  BCF    3A.7
0516:  BTFSC  5F.7
0517:  BSF    3A.7
....................     if (b_CANINTF.merrf) 
0518:  BTFSC  5F.7
....................     { 
....................        b_CANINTF.merrf=0; 
0519:  BCF    5F.7
....................     } 
....................      
....................     if (stat.buffer) 
051A:  BTFSS  3A.4
051B:  GOTO   51E
....................     { 
....................        b_CANINTF.rx1if=0; 
051C:  BCF    5F.1
....................     } 
051D:  GOTO   51F
....................     else 
....................     { 
....................        b_CANINTF.rx0if=0; 
051E:  BCF    5F.0
....................     } 
....................      
....................     mcp2510_write(CANINTF, (unsigned int8)b_CANINTF); 
051F:  MOVLW  2C
0520:  MOVWF  66
0521:  MOVF   5F,W
0522:  MOVWF  67
0523:  CALL   0AC
....................  
....................     #if CAN_DO_DEBUG 
....................         
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr))  
....................        { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++)  
....................           { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
0524:  MOVLW  01
0525:  MOVWF  21
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_kbhit() 
.................... // 
.................... // Returns TRUE if there is data in the receive buffers 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_kbhit(void) 
.................... { 
....................    struct struct_CANINTF b_CANINTF; 
....................  
....................    //b_CANINTF=mcp2510_read(CANINTF); 
....................    memset(&b_CANINTF,mcp2510_read(CANINTF),1); 
....................    if (b_CANINTF.rx0if || b_CANINTF.rx1if) 
....................    { 
....................       return(1); 
....................    } 
....................  
....................    return(0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_tbe() 
.................... // 
.................... // Returns TRUE if the transmit buffers are empty and ready to transmit data 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_tbe(void) 
.................... { 
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL; 
....................  
....................    //b_TXB0CTRL=mcp2510_read(TXB0CTRL); 
....................    memset(&b_TXB0CTRL,mcp2510_read(TXB0CTRL),1); 
....................    //b_TXB1CTRL=mcp2510_read(TXB1CTRL); 
....................    memset(&b_TXB1CTRL,mcp2510_read(TXB1CTRL),1); 
....................    //b_TXB2CTRL=mcp2510_read(TXB2CTRL); 
....................    memset(&b_TXB2CTRL,mcp2510_read(TXB2CTRL),1); 
....................  
....................    if (!b_TXB0CTRL.txreq || !b_TXB1CTRL.txreq || !b_TXB2CTRL.txreq) 
....................    { 
....................       return(1); 
....................    } 
....................  
....................    return(0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_abort() 
.................... // 
.................... // Aborts all pending tranmissions. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_abort(void) 
.................... { 
....................    struct struct_CANCTRL b_CANCTRL; 
....................  
....................    //b_CANCTRL=mcp2510_read(CANCTRL); 
....................    memset(&b_CANCTRL,mcp2510_read(CANCTRL),1); 
....................    b_CANCTRL.abat=1; 
....................    mcp2510_write(CANCTRL, (unsigned int8)b_CANCTRL); 
....................  
....................    delay_ms(5); 
....................    b_CANCTRL.abat=0; 
....................    mcp2510_write(CANCTRL, (unsigned int8)b_CANCTRL); 
.................... } 
....................  
.................... void can_set_interr(int8 interr) 
.................... { 
....................    ///////ADICIONADO: FERNANDO 
....................    mcp2510_write(CANINTE,interr); 
*
026C:  MOVLW  2B
026D:  MOVWF  66
026E:  MOVF   3A,W
026F:  MOVWF  67
0270:  CALL   0AC
0271:  MOVLP  00
0272:  GOTO   623 (RETURN)
.................... } 
....................  
....................  
.................... /////////////////// 
.................... /// 
.................... // 
.................... // SPI CODE 
.................... // 
.................... /// 
.................... ////////////////// 
.................... //! 
....................  
.................... #ifndef USE_HARDWARE_SPI 
....................    #use spi(MASTER,MODE=0,DI=EXT_CAN_SI,DO=EXT_CAN_SO,CLK=EXT_CAN_SCK,bits=8,stream=MCP2510) 
*
0056:  MOVLB  01
0057:  MOVF   28,W
0058:  SUBLW  08
0059:  BTFSC  03.2
005A:  GOTO   05F
005B:  MOVWF  29
005C:  RLF    27,F
005D:  DECFSZ 29,F
005E:  GOTO   05C
005F:  BSF    0E.1
0060:  BCF    0E.2
0061:  BCF    0E.0
0062:  MOVLB  02
0063:  BCF    0E.0
0064:  MOVLB  01
0065:  MOVF   28,W
0066:  MOVWF  29
0067:  BTFSC  27.7
0068:  GOTO   06C
0069:  MOVLB  02
006A:  BCF    0E.2
006B:  MOVLB  01
006C:  BTFSS  27.7
006D:  GOTO   071
006E:  MOVLB  02
006F:  BSF    0E.2
0070:  MOVLB  01
0071:  RLF    27,F
0072:  MOVLB  02
0073:  BSF    0E.0
0074:  MOVLB  00
0075:  RLF    21,F
0076:  BTFSS  0E.1
0077:  BCF    21.0
0078:  BTFSC  0E.1
0079:  BSF    21.0
007A:  MOVLB  02
007B:  BCF    0E.0
007C:  MOVLB  01
007D:  DECFSZ 29,F
007E:  GOTO   067
007F:  MOVLB  00
0080:  RETURN
.................... #else 
....................    //#USE SPI (MASTER, SPI1, MODE=0, BITS=8, STREAM=MCP2510) 
....................    #use spi(MASTER,MODE=0,DI=EXT_CAN_SI,DO=EXT_CAN_SO,CLK=EXT_CAN_SCK,bits=8,stream=MCP2510,FORCE_HW) 
.................... #endif 
.................... //! 
....................  
.................... //data clocked in on rising edge 
.................... //data driven out on falling edge 
.................... unsigned int8 mcp2510_read(unsigned int8 address) 
.................... { 
....................    unsigned int8 data; 
....................  
....................    output_low(EXT_CAN_CS); 
0081:  MOVLB  01
0082:  BCF    0E.3
0083:  MOVLB  02
0084:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,0x03); 
0085:  MOVLW  03
0086:  MOVLB  01
0087:  MOVWF  27
0088:  MOVLW  08
0089:  MOVWF  28
008A:  MOVLB  00
008B:  CALL   056
....................    spi_xfer(MCP2510,address); 
008C:  MOVLB  01
008D:  MOVF   25,W
008E:  MOVWF  27
008F:  MOVLW  08
0090:  MOVWF  28
0091:  MOVLB  00
0092:  CALL   056
....................    data =spi_xfer(MCP2510,0); 
0093:  MOVLB  01
0094:  CLRF   27
0095:  MOVLW  08
0096:  MOVWF  28
0097:  MOVLB  00
0098:  CALL   056
0099:  MOVF   21,W
009A:  MOVLB  01
009B:  MOVWF  26
....................     
....................    output_high(EXT_CAN_CS); 
009C:  BCF    0E.3
009D:  MOVLB  02
009E:  BSF    0E.3
....................  
....................    return(data); 
009F:  MOVLB  01
00A0:  MOVF   26,W
00A1:  MOVLB  00
00A2:  MOVWF  21
00A3:  RETURN
.................... } 
....................  
.................... unsigned int8 mcp2510_status(void) 
.................... { 
....................    unsigned int8 data; 
....................     
....................    output_low(EXT_CAN_CS); 
....................     
....................    spi_xfer(MCP2510,0xA0); 
....................    data = spi_xfer(MCP2510,0); 
....................    spi_xfer(MCP2510,0); 
....................     
....................    output_high(EXT_CAN_CS); 
....................  
....................    return(data); 
.................... } 
....................  
....................  
.................... void mcp2510_write(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    output_low(EXT_CAN_CS); 
*
00AC:  MOVLB  01
00AD:  BCF    0E.3
00AE:  MOVLB  02
00AF:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,0x02); 
00B0:  MOVLW  02
00B1:  MOVLB  01
00B2:  MOVWF  27
00B3:  MOVLW  08
00B4:  MOVWF  28
00B5:  MOVLB  00
00B6:  CALL   056
....................    spi_xfer(MCP2510,address); 
00B7:  MOVF   66,W
00B8:  MOVLB  01
00B9:  MOVWF  27
00BA:  MOVLW  08
00BB:  MOVWF  28
00BC:  MOVLB  00
00BD:  CALL   056
....................    spi_xfer(MCP2510,data); 
00BE:  MOVF   67,W
00BF:  MOVLB  01
00C0:  MOVWF  27
00C1:  MOVLW  08
00C2:  MOVWF  28
00C3:  MOVLB  00
00C4:  CALL   056
....................     
....................    output_high(EXT_CAN_CS); 
00C5:  MOVLB  01
00C6:  BCF    0E.3
00C7:  MOVLB  02
00C8:  BSF    0E.3
00C9:  MOVLB  00
00CA:  RETURN
.................... } 
....................  
.................... void mcp2510_command(unsigned int8 command) 
.................... { 
....................    output_low(EXT_CAN_CS); 
*
01C6:  MOVLB  01
01C7:  BCF    0E.3
01C8:  MOVLB  02
01C9:  BCF    0E.3
....................     
....................    spi_xfer(MCP2510,command); 
01CA:  MOVLB  00
01CB:  MOVF   3B,W
01CC:  MOVLB  01
01CD:  MOVWF  27
01CE:  MOVLW  08
01CF:  MOVWF  28
01D0:  MOVLB  00
01D1:  CALL   056
....................     
....................    output_high(EXT_CAN_CS); 
01D2:  MOVLB  01
01D3:  BCF    0E.3
01D4:  MOVLB  02
01D5:  BSF    0E.3
.................... } 
....................  
.................... void mcp2510_bitmodify(unsigned int8 address, unsigned int8 mask, unsigned int8 data) 
.................... { 
....................    output_low(EXT_CAN_CS); 
....................     
....................    spi_xfer(MCP2510,0x05); 
....................    spi_xfer(MCP2510,address); 
....................    spi_xfer(MCP2510,mask); 
....................    spi_xfer(MCP2510,data); 
....................     
....................    output_high(EXT_CAN_CS); 
.................... } 
....................  
....................  
.................... void mcp2510_init(void) 
.................... { 
....................    output_high(EXT_CAN_CS); 
*
01B5:  MOVLB  01
01B6:  BCF    0E.3
01B7:  MOVLB  02
01B8:  BSF    0E.3
....................    output_low(EXT_CAN_SI); 
01B9:  MOVLB  01
01BA:  BCF    0E.1
01BB:  MOVLB  02
01BC:  BCF    0E.1
....................    output_low(EXT_CAN_SCK); 
01BD:  MOVLB  01
01BE:  BCF    0E.0
01BF:  MOVLB  02
01C0:  BCF    0E.0
....................    output_float(EXT_CAN_SO); 
01C1:  MOVLB  01
01C2:  BSF    0E.2
....................  
....................    #ifdef EXT_CAN_TX0RTS 
....................     output_high(EXT_CAN_TX0RTS); 
....................    #endif 
....................    #ifdef EXT_CAN_TX1RTS 
....................     output_high(EXT_CAN_TX1RTS); 
....................    #endif 
....................    #ifdef EXT_CAN_TX2RTS 
....................     output_high(EXT_CAN_TX2RTS); 
....................    #endif 
....................  
....................   #ifdef EXT_CAN_TX0RTS 
....................    output_high(EXT_CAN_RESET); 
....................    output_low(EXT_CAN_RESET); 
....................    output_high(EXT_CAN_RESET); 
....................    delay_ms(20); 
....................   #endif 
....................    
....................    mcp2510_command(0xC0);   //reset 
01C3:  MOVLW  C0
01C4:  MOVLB  00
01C5:  MOVWF  3B
....................     
....................    delay_ms(20); 
*
01D6:  MOVLW  14
01D7:  MOVLB  00
01D8:  MOVWF  5A
01D9:  CALL   040
.................... } 
....................  
....................  
.................... //void can_debug(int) 
....................  
.................... #include <placa_plus.h> 
.................... //******************************** 
.................... //*   EEPROM                     * 
.................... //******************************** 
.................... //DEFINE EEPROM_NOME PRIMEIRO ENDERECO,TAMANHO BYTES 
....................  
.................... //conta transmissões perdidas na CAN - bytes 0 a 3 
.................... #ROM 0xF000 = {0x00,0x00,0x00,0x00} 
.................... #DEFINE EP_NAO_TRANS 0x00,0x04 
....................  
.................... //conta quantas horas ligado desde o ultimo reset - bytes 4 a 5 
.................... #ROM 0xF004 = {0x00,0x00} 
.................... #DEFINE EP_HORA_LIGADO 0x04,0x02 
....................  
.................... //conta erros de comunicação com MCP - bytes 6 a 9 
.................... #ROM 0xF006 = {0x00,0x00,0x00,0x00} 
.................... #DEFINE EP_MCP 0x06,0x04 
....................  
.................... //SELETOR DE FREQUENCIA - byte 0A 
.................... #ROM 0xF006 = {0x00} 
.................... #DEFINE EP_ID 0x0A,0x01 
....................  
.................... #DEFINE int_per_sec 16 
....................  
.................... //******************************** 
....................  
.................... volatile unsigned int32 erro_nao_trans = 0, 
....................                         erro_mcp = 0; 
....................  
.................... volatile unsigned int16 horas_ligado = 0; 
....................  
.................... volatile unsigned int8 counter = 0, 
....................                        sec = 0, 
....................                        min = 0; 
....................                                                
.................... volatile unsigned int1 um_segundo = 0b0,  
....................                        um_minuto = 0b0, 
....................                        uma_hora = 0b0, 
....................                        flag_interr = 0b0, 
....................                        flag_envio = 0b0, 
....................                        flag_receb = 0b0, 
....................                        erro_nao_trans_flag = 0, 
....................                        erro_mcp_flag = 0; 
....................    
.................... void external_can_interrupt (); 
.................... int8 detecta_freq(void); 
.................... void setup_can(void); 
.................... void piscaLed(char nPisca, int16 delay, int8 led); 
.................... void eeprom_grava(unsigned int8 address, unsigned int8 tamanho, unsigned int32 hexa); 
.................... unsigned int32 eeprom_le(unsigned int8 address, unsigned int8 tamanho); 
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(){  // interrupt routine     
....................    set_timer1(3000); 
*
0023:  CLRF   16
0024:  MOVLW  0B
0025:  MOVWF  17
0026:  MOVLW  B8
0027:  MOVWF  16
....................    counter--;  // decrements counter which is set to it_per_sec  
0028:  DECFSZ 36,F
....................     
....................    //SEGUNDOS 
....................    if(counter==0){          
0029:  GOTO   02E
....................       sec++;                 
002A:  INCF   37,F
....................       counter=int_per_sec; //resets counter 
002B:  MOVLW  10
002C:  MOVWF  36
....................       //contador_seg++; 
....................       um_segundo = 0b01; 
002D:  BSF    39.0
....................    }  
....................  
....................    //MINUTOS 
....................    if(sec==60){  
002E:  MOVF   37,W
002F:  SUBLW  3C
0030:  BTFSS  03.2
0031:  GOTO   035
....................       sec=0;        
0032:  CLRF   37
....................       min++; 
0033:  INCF   38,F
....................       um_minuto = 0b1; 
0034:  BSF    39.1
....................    } 
....................      
....................    //HORAS 
....................    if(min==60) {  
0035:  MOVF   38,W
0036:  SUBLW  3C
0037:  BTFSC  03.2
....................       min=0; 
0038:  CLRF   38
....................       //atualizar dados da eeprom aqui 
....................    } 
.................... } 
....................  
0039:  BCF    11.0
003A:  MOVLP  00
003B:  GOTO   01A
.................... #int_ext 
.................... void external_can_interrupt () 
.................... { 
....................    flag_interr = 0b1; 
003C:  BSF    39.3
003D:  BCF    0B.1
003E:  MOVLP  00
003F:  GOTO   01A
.................... } 
....................  
.................... int8 detecta_freq(void) 
.................... { 
....................    int8 freq, i; 
....................    for(freq = 0; freq < 6; freq++) 
....................    { 
....................       can_set_mode(CAN_OP_CONFIG); 
....................       set_freq_var(freq); 
....................       can_set_baud(); 
....................       can_set_mode(CAN_OP_LISTEN); 
....................        
....................       for(i = 0; i < 8; i++) 
....................       { 
....................          delay_ms(500); 
....................          if(can_kbhit()) return freq; 
....................       }    
....................       piscaLed(1,1,LED2); 
....................    } 
....................    return 0xff; 
.................... } 
....................  
.................... void setup_can(int1 frequencia_eeprom, unsigned int8 interr, unsigned int8 can_mode) 
.................... { 
....................    int8 freq = 0; 
....................    can_init(); 
....................     
.................... //!   can_set_mode(CAN_OP_CONFIG); 
.................... //!   can_set_id(RX0MASK,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX0FILTER0,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX0FILTER1,0x7E0,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1MASK,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER2,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER3,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER4,0x223,CAN_USE_EXTENDED_ID); 
.................... //!   can_set_id(RX1FILTER5,0x223,CAN_USE_EXTENDED_ID); 
....................  
....................    frequencia_eeprom ? (freq = eeprom_le(EP_ID)) : (freq = detecta_freq()); 
....................    
....................    set_freq_var(freq); 
....................    can_set_interr(interr); 
....................    can_set_mode(can_mode);  
.................... } 
....................  
.................... void piscaLed(char nPisca, unsigned int16 delay, unsigned int8 led) 
*
054B:  CLRF   58
.................... { 
....................      char i = 0; 
....................       
....................      for(i = 0; i < nPisca; i++){ 
054C:  CLRF   58
054D:  MOVF   54,W
054E:  SUBWF  58,W
054F:  BTFSC  03.0
0550:  GOTO   57F
....................          output_high(led); 
0551:  MOVF   57,W
0552:  MOVWF  59
0553:  MOVLW  01
0554:  MOVWF  5A
0555:  MOVWF  5C
0556:  CLRF   5B
0557:  CALL   2B7
0558:  MOVF   57,W
0559:  MOVWF  59
055A:  CLRF   5A
055B:  CLRF   5C
055C:  MOVLW  80
055D:  MOVWF  5B
055E:  CALL   2B7
....................          delay_ms(20); 
055F:  MOVLW  14
0560:  MOVWF  5A
0561:  CALL   040
....................          output_low(led); 
0562:  MOVF   57,W
0563:  MOVWF  59
0564:  CLRF   5A
0565:  MOVLW  01
0566:  MOVWF  5C
0567:  CLRF   5B
0568:  CALL   2B7
0569:  MOVF   57,W
056A:  MOVWF  59
056B:  CLRF   5A
056C:  CLRF   5C
056D:  MOVLW  80
056E:  MOVWF  5B
056F:  CALL   2B7
....................          delay_ms(delay); 
0570:  MOVF   56,W
0571:  MOVWF  59
0572:  INCF   59,F
0573:  DECF   59,F
0574:  BTFSC  03.2
0575:  GOTO   57A
0576:  MOVLW  FF
0577:  MOVWF  5A
0578:  CALL   040
0579:  GOTO   573
057A:  MOVF   55,W
057B:  MOVWF  5A
057C:  CALL   040
057D:  INCF   58,F
057E:  GOTO   54D
....................      } 
.................... } 
....................  
.................... void eeprom_grava(unsigned int8 address, unsigned int8 tamanho, unsigned int32 hexa) 
.................... { 
....................    unsigned int8 i = 0, bytes[4];                
....................     
....................    //separa bytes 
....................    for (i = 0; i < tamanho; i++) 
....................    { 
....................      bytes[i] = hexa; 
....................      hexa >>= 8; 
....................    } 
....................       
....................    //imprime na ordem inversa 
....................    while(tamanho)  
....................    { 
....................       write_eeprom(address++,bytes[--tamanho]); 
....................       delay_ms(1); 
....................    } 
.................... } 
....................  
.................... unsigned int32 eeprom_le(unsigned int8 address, unsigned int8 tamanho) 
.................... { 
....................    unsigned int8 i = 0; 
....................    unsigned int32 bytes = 0; 
....................     
....................    for(i = tamanho; i > 0; i--) 
....................    { 
....................       bytes <<= 8; 
....................       bytes |= read_eeprom(address++);  
....................       delay_ms(1); 
....................    } 
....................    return bytes; 
.................... } 
....................  
....................  
....................  
.................... #define MASTER 200 
.................... #define RECEPTOR1 303 
....................  
.................... void trata_dado() 
.................... { 
....................    struct rx_stat rxstat; 
....................    int32 tx_id; 
....................    int8 rx_len;    
....................    int32 rx_id; 
....................    int8 dadosEnv[8] = {0xAA,0xBB}, 
*
02D7:  MOVLW  AA
02D8:  MOVWF  44
02D9:  MOVLW  BB
02DA:  MOVWF  45
02DB:  CLRF   46
02DC:  CLRF   47
02DD:  CLRF   48
02DE:  CLRF   49
02DF:  CLRF   4A
02E0:  CLRF   4B
....................         dadosRec[8] = {0xAA,0xBB}; 
02E1:  MOVLW  AA
02E2:  MOVWF  4C
02E3:  MOVLW  BB
02E4:  MOVWF  4D
02E5:  CLRF   4E
02E6:  CLRF   4F
02E7:  CLRF   50
02E8:  CLRF   51
02E9:  CLRF   52
02EA:  CLRF   53
....................          
....................    flag_receb = 0b0;   
02EB:  BCF    39.5
....................    if(can_getd (rx_id, dadosRec, rx_len, rxstat)) 
02EC:  MOVLW  20
02ED:  MOVWF  55
02EE:  MOVLW  2C
02EF:  MOVWF  54
*
0526:  MOVF   21,F
0527:  BTFSC  03.2
0528:  GOTO   57F
....................    { 
....................       if(dadosRec[0] == 0xAA) 
0529:  MOVF   4C,W
052A:  SUBLW  AA
052B:  BTFSS  03.2
052C:  GOTO   537
....................       { 
....................          output_high(LED2); 
052D:  MOVLB  01
052E:  BCF    0C.4
052F:  MOVLB  02
0530:  BSF    0C.4
....................          output_low(SAIDA1); 
0531:  MOVLB  01
0532:  BCF    0E.5
0533:  MOVLB  02
0534:  BCF    0E.5
....................       } 
0535:  GOTO   543
0536:  MOVLB  00
....................       else if(dadosRec[0] == 0xBB) 
0537:  MOVF   4C,W
0538:  SUBLW  BB
0539:  BTFSS  03.2
053A:  GOTO   544
....................       { 
....................          output_low(LED2); 
053B:  MOVLB  01
053C:  BCF    0C.4
053D:  MOVLB  02
053E:  BCF    0C.4
....................          output_high(SAIDA1); 
053F:  MOVLB  01
0540:  BCF    0E.5
0541:  MOVLB  02
0542:  BSF    0E.5
0543:  MOVLB  00
....................       } 
....................       piscaLed(1,50,LED1);  
0544:  MOVLW  01
0545:  MOVWF  54
0546:  CLRF   56
0547:  MOVLW  32
0548:  MOVWF  55
0549:  MOVLW  65
054A:  MOVWF  57
....................    } 
*
057F:  MOVLP  00
0580:  GOTO   652 (RETURN)
....................      
.................... } 
....................  
.................... //interrupcoes 
.................... unsigned int8 trata_interr() 
*
0273:  CLRF   3C
.................... { 
....................    unsigned int8 int_id,i,int_unitario = 0x00;  
....................     
....................    int_id = mcp2510_read(CANINTF); 
0274:  MOVLW  2C
0275:  MOVLB  01
0276:  MOVWF  25
0277:  MOVLB  00
0278:  CALL   081
0279:  MOVF   21,W
027A:  MOVWF  3A
....................    //int_unitario retorna o bit mais significativ de i 
....................    if(int_id) 
027B:  MOVF   3A,F
027C:  BTFSC  03.2
027D:  GOTO   28C
....................    { 
....................       for (i = 1; i != 0; i<<=1) 
027E:  MOVLW  01
027F:  MOVWF  3B
0280:  MOVF   3B,F
0281:  BTFSC  03.2
0282:  GOTO   28C
....................       { 
....................          if ((int_id & i) != 0) {int_unitario = i;} 
0283:  MOVF   3A,W
0284:  ANDWF  3B,W
0285:  BTFSC  03.2
0286:  GOTO   289
0287:  MOVF   3B,W
0288:  MOVWF  3C
0289:  BCF    03.0
028A:  RLF    3B,F
028B:  GOTO   280
....................       }    
....................    } 
....................  
....................     
....................    //int_unitario ee a interrupcao mais importante 
....................    switch (int_unitario) 
028C:  MOVF   3C,W
028D:  XORLW  01
028E:  BTFSC  03.2
028F:  GOTO   2A6
0290:  XORLW  03
0291:  BTFSC  03.2
0292:  GOTO   2A8
0293:  XORLW  06
0294:  BTFSC  03.2
0295:  GOTO   2AA
0296:  XORLW  0C
0297:  BTFSC  03.2
0298:  GOTO   2AB
0299:  XORLW  18
029A:  BTFSC  03.2
029B:  GOTO   2AC
029C:  XORLW  30
029D:  BTFSC  03.2
029E:  GOTO   2AD
029F:  XORLW  60
02A0:  BTFSC  03.2
02A1:  GOTO   2AE
02A2:  XORLW  C0
02A3:  BTFSC  03.2
02A4:  GOTO   2AF
02A5:  GOTO   2B0
....................    { 
....................       case CAN_RX0_INT: 
....................          flag_receb = 0b1; 
02A6:  BSF    39.5
....................          break; 
02A7:  GOTO   2B0
....................        
....................       case CAN_RX1_INT: 
....................          flag_receb = 0b1; 
02A8:  BSF    39.5
....................          break; 
02A9:  GOTO   2B0
....................        
....................       case CAN_TX0_INT: 
....................          break; 
02AA:  GOTO   2B0
....................        
....................       case CAN_TX1_INT: 
....................          break; 
02AB:  GOTO   2B0
....................    
....................       case CAN_TX2_INT: 
....................          break; 
02AC:  GOTO   2B0
....................        
....................       case CAN_ERROR_INT: 
....................          break; 
02AD:  GOTO   2B0
....................        
....................       case CAN_WAKE_INT: 
....................          break; 
02AE:  GOTO   2B0
....................        
....................       case CAN_MESERR_INT: 
....................          break; 
02AF:  GOTO   2B0
....................        
....................       default:  
....................          break; //erro! 
....................    } 
....................     
....................    //mcp2510_bitmodify(CANINTF,int_unitario,0x00); 
....................    int_id &= ~int_unitario; 
02B0:  MOVF   3C,W
02B1:  XORLW  FF
02B2:  ANDWF  3A,F
....................    return int_id; 
02B3:  MOVF   3A,W
02B4:  MOVWF  21
02B5:  MOVLP  00
02B6:  GOTO   650 (RETURN)
.................... } 
....................  
.................... //!void trata_interr() 
.................... //!{ 
.................... //!   int int_id = mcp2510_read(CANINTF); 
.................... //!   mcp2510_bitmodify(CANINTF,int_id,0x00); 
.................... //!    
.................... //!   flag_interr = 0b0; 
.................... //!    
.................... //!   if(int_id & CAN_MESERR_INT) 
.................... //!   { 
.................... //!      output_low(PIN_A1); 
.................... //!   } 
.................... //!    
.................... //!    
.................... //!   //else if(int_id & CAN_WAKE_INT) {} 
.................... //!   //else if(int_id & CAN_ERROR_INT) {} 
.................... //!   //else if(int_id & CAN_TX2_INT) {} 
.................... //!   //else if(int_id & CAN_TX1_INT) {} 
.................... //!   //else if(int_id & CAN_TX0_INT) {} 
.................... //!   //else if(int_id & CAN_RX1_INT) {} 
.................... //!   //else if(int_id & CAN_RX0_INT) {} 
.................... //!} 
....................  
....................  
.................... void main() 
*
0581:  MOVLW  6A
0582:  MOVLB  01
0583:  MOVWF  19
0584:  MOVLB  02
0585:  BSF    00.0
0586:  MOVLB  00
0587:  CLRF   28
0588:  MOVLW  01
0589:  MOVWF  29
058A:  MOVWF  2A
058B:  MOVLW  02
058C:  MOVWF  2B
058D:  MOVLB  01
058E:  BSF    0E.1
058F:  BCF    0E.2
0590:  BCF    0E.0
0591:  MOVLB  02
0592:  BCF    0E.0
0593:  MOVLB  00
0594:  CLRF   2F
0595:  CLRF   2E
0596:  CLRF   2D
0597:  CLRF   2C
0598:  CLRF   33
0599:  CLRF   32
059A:  CLRF   31
059B:  CLRF   30
059C:  CLRF   35
059D:  CLRF   34
059E:  CLRF   36
059F:  CLRF   37
05A0:  CLRF   38
05A1:  BCF    39.0
05A2:  BCF    39.1
05A3:  BCF    39.2
05A4:  BCF    39.3
05A5:  BCF    39.4
05A6:  BCF    39.5
05A7:  BCF    39.6
05A8:  BCF    39.7
05A9:  MOVLB  03
05AA:  CLRF   0C
05AB:  CLRF   0E
05AC:  MOVLB  02
05AD:  CLRF   12
05AE:  CLRF   11
05AF:  CLRF   14
05B0:  CLRF   13
.................... {   
....................    //VEJA placa_plus.h 
....................    set_tris_a(0b00001100); 
05B1:  MOVLW  0C
05B2:  TRIS   5
....................    set_tris_c(0b00000010); 
05B3:  MOVLW  02
05B4:  TRIS   7
....................    output_low(LED1); 
05B5:  MOVLB  01
05B6:  BCF    0C.5
05B7:  MOVLB  02
05B8:  BCF    0C.5
....................    output_low(LED2); 
05B9:  MOVLB  01
05BA:  BCF    0C.4
05BB:  MOVLB  02
05BC:  BCF    0C.4
....................     
....................    output_high(LED1); 
05BD:  MOVLB  01
05BE:  BCF    0C.5
05BF:  MOVLB  02
05C0:  BSF    0C.5
....................    delay_ms(200); 
05C1:  MOVLW  C8
05C2:  MOVLB  00
05C3:  MOVWF  5A
05C4:  CALL   040
....................  
....................    can_init(); 
05C5:  GOTO   1B5
....................  
....................    output_low(LED1); 
05C6:  MOVLB  01
05C7:  BCF    0C.5
05C8:  MOVLB  02
05C9:  BCF    0C.5
....................    delay_ms(200); 
05CA:  MOVLW  C8
05CB:  MOVLB  00
05CC:  MOVWF  5A
05CD:  CALL   040
....................     
....................    can_set_mode(CAN_OP_CONFIG); 
05CE:  MOVLW  04
05CF:  MOVWF  3B
05D0:  CALL   0CB
....................    can_set_id(RX0MASK,0x71F,CAN_USE_EXTENDED_ID); 
05D1:  MOVLW  23
05D2:  MOVWF  3B
05D3:  CLRF   3F
05D4:  CLRF   3E
05D5:  MOVLW  07
05D6:  MOVWF  3D
05D7:  MOVLW  1F
05D8:  MOVWF  3C
05D9:  CLRF   40
05DA:  CALL   102
....................    can_set_id(RX0FILTER0,0x71F,CAN_USE_EXTENDED_ID); 
05DB:  MOVLW  03
05DC:  MOVWF  3B
05DD:  CLRF   3F
05DE:  CLRF   3E
05DF:  MOVLW  07
05E0:  MOVWF  3D
05E1:  MOVLW  1F
05E2:  MOVWF  3C
05E3:  CLRF   40
05E4:  CALL   102
....................    can_set_id(RX0FILTER1,0x71F,CAN_USE_EXTENDED_ID); 
05E5:  MOVLW  07
05E6:  MOVWF  3B
05E7:  CLRF   3F
05E8:  CLRF   3E
05E9:  MOVWF  3D
05EA:  MOVLW  1F
05EB:  MOVWF  3C
05EC:  CLRF   40
05ED:  CALL   102
....................    can_set_id(RX1MASK,0x71F,CAN_USE_EXTENDED_ID); 
05EE:  MOVLW  27
05EF:  MOVWF  3B
05F0:  CLRF   3F
05F1:  CLRF   3E
05F2:  MOVLW  07
05F3:  MOVWF  3D
05F4:  MOVLW  1F
05F5:  MOVWF  3C
05F6:  CLRF   40
05F7:  CALL   102
....................    can_set_id(RX1FILTER2,0x71F,CAN_USE_EXTENDED_ID); 
05F8:  MOVLW  0B
05F9:  MOVWF  3B
05FA:  CLRF   3F
05FB:  CLRF   3E
05FC:  MOVLW  07
05FD:  MOVWF  3D
05FE:  MOVLW  1F
05FF:  MOVWF  3C
0600:  CLRF   40
0601:  CALL   102
....................    can_set_id(RX1FILTER3,0x71F,CAN_USE_EXTENDED_ID); 
0602:  MOVLW  13
0603:  MOVWF  3B
0604:  CLRF   3F
0605:  CLRF   3E
0606:  MOVLW  07
0607:  MOVWF  3D
0608:  MOVLW  1F
0609:  MOVWF  3C
060A:  CLRF   40
060B:  CALL   102
....................    can_set_id(RX1FILTER4,0x71F,CAN_USE_EXTENDED_ID); 
060C:  MOVLW  17
060D:  MOVWF  3B
060E:  CLRF   3F
060F:  CLRF   3E
0610:  MOVLW  07
0611:  MOVWF  3D
0612:  MOVLW  1F
0613:  MOVWF  3C
0614:  CLRF   40
0615:  CALL   102
....................    can_set_id(RX1FILTER5,0x71F,CAN_USE_EXTENDED_ID); 
0616:  MOVLW  1B
0617:  MOVWF  3B
0618:  CLRF   3F
0619:  CLRF   3E
061A:  MOVLW  07
061B:  MOVWF  3D
061C:  MOVLW  1F
061D:  MOVWF  3C
061E:  CLRF   40
061F:  CALL   102
....................    can_set_interr(0x03); 
0620:  MOVLW  03
0621:  MOVWF  3A
0622:  GOTO   26C
....................    can_set_mode(CAN_OP_NORMAL); 
0623:  CLRF   3B
0624:  CALL   0CB
....................  
....................    output_high(LED1); 
0625:  MOVLB  01
0626:  BCF    0C.5
0627:  MOVLB  02
0628:  BSF    0C.5
....................    delay_ms(200); 
0629:  MOVLW  C8
062A:  MOVLB  00
062B:  MOVWF  5A
062C:  CALL   040
....................     
.................... //===========REGISTRADORES=================================== 
....................    disable_interrupts(GLOBAL);                 // habilitar interr global 
062D:  BCF    0B.6
062E:  BCF    0B.7
062F:  BTFSC  0B.7
0630:  GOTO   62E
....................    enable_interrupts(INT_EXT_H2L);             // interrupï¿½ï¿½o CAN 
0631:  BSF    0B.4
0632:  MOVLB  01
0633:  BCF    15.6
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);   // setar timer1 para interno 
0634:  MOVLB  02
0635:  BCF    1D.3
0636:  MOVLW  05
0637:  MOVLB  00
0638:  MOVWF  18
0639:  CLRF   19
....................    enable_interrupts(INT_TIMER1);              // habilita Timer1  
063A:  MOVLB  01
063B:  BSF    11.0
....................    set_timer1(0);                              // limpar flag TMR1H & TMR1L  
063C:  MOVLB  00
063D:  CLRF   16
063E:  CLRF   17
063F:  CLRF   16
....................    counter=int_per_sec; 
0640:  MOVLW  10
0641:  MOVWF  36
....................    enable_interrupts(GLOBAL);                  // habilitar interr global 
0642:  MOVLW  C0
0643:  IORWF  0B,F
.................... //---------------------------------------------------------- 
....................  
....................    output_low(LED1); 
0644:  MOVLB  01
0645:  BCF    0C.5
0646:  MOVLB  02
0647:  BCF    0C.5
....................    delay_ms(200); 
0648:  MOVLW  C8
0649:  MOVLB  00
064A:  MOVWF  5A
064B:  CALL   040
....................  
....................    while(TRUE) 
....................    { 
....................       if(flag_interr) 
064C:  BTFSS  39.3
064D:  GOTO   650
....................       {     
....................          flag_interr = 0b0; 
064E:  BCF    39.3
....................          trata_interr();         
064F:  GOTO   273
....................       } 
....................        
....................       if(flag_receb) 
0650:  BTFSC  39.5
....................       { 
....................          trata_dado(); 
0651:  GOTO   2D7
....................          //piscaLed(1,1,LED2); 
....................       } 
....................           
....................       if(um_segundo) 
0652:  BTFSC  39.0
....................       {       
....................          um_segundo = 0b0; 
0653:  BCF    39.0
....................           
....................       } 
0654:  GOTO   64C
....................    } 
.................... } 
....................  
0655:  SLEEP
....................  

Configuration Fuses:
   Word  1: 3984   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
00F000: 0000 0000 0000 0000 0000 0000 0000 0000 
00F008: 0000 0000 

00F006: 0000 
