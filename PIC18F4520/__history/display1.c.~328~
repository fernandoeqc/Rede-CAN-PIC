#include <display1.h>
#include <LCDedit.c>
#include <devboard.c>
#include <can-mcp2515.c>

#define MASTER 200
#define RECEPTOR1 303

//interrupções
enum {CAN_RX0_INT=1,CAN_RX1_INT=2,CAN_TX0_INT=4,CAN_TX1_INT=8,CAN_TX2_INT=16,CAN_ERROR_INT=32,CAN_WAKE_INT=64,CAN_MESERR_INT=128};
int1 interr = 0b0;

#INT_EXT
void external_can_interrupt (){
   int int_id;
   int_id=mcp2510_read(CANINTF);

   output_toggle(LED1);
   
   switch(int_id) {
   case CAN_RX0_INT:
      interr = 1;//interr = int_id;lcd_putc("ENCONTRADO");// add receive code here
      break;
      
   case CAN_RX1_INT:
      interr = 1;//lcd_putc("ENCONTRADO");// add receive code here
      break;
      
   case CAN_ERROR_INT:
      
      // add error code here
      break;
   case CAN_MESERR_INT:
       
      // add message error code here
      break;
   case CAN_TX0_INT:
      output_high(LED2);
      break;
   case CAN_TX1_INT:

      break;
   case CAN_TX2_INT:
     
      break;

   }
}

#INT_TIMER0
void  TIMER0_isr(void) 
{
   //output_toggle(LED1);
}

int8 dados_env_buf[8];
int1 verif_novo_dado(*dadosEnv, tam_dado)
{
   int8 i;
   int1 diferente = 0b0;
   
   for(i = 0; i < tam_dado; i++)
   {
      if(dadosEnv[i] != dados_env_buf[i])
      {
         dados_env_buf[i] = dadosEnv[i];
         diferente = 0b1;
         write_eeprom(i,dados_env_buf[i]);
      }
   }
   return diferente;
}

int1 can_loop(void)
{
   struct rx_stat rxstat;
   int32 rx_id;
   int32 tx_id;
   int8 rx_len,
   dadosRec[8];
   
   //can_putd(200,dadosEnv_p,2,0,0,0);
   //delay_ms(10);
   
   if(can_kbhit())
   {
      if (can_getd (rx_id, dadosRec, rx_len, rxstat))
      {
         return 0b1; 
      }   
   }
   return 0b0;
}

int8 detecta_freq(void)
{
   int8 freq, i;
   for(freq = 0; freq < 6; freq++)
   {
      can_set_mode(CAN_OP_CONFIG);
      set_freq_var(freq);
      can_set_baud();
      can_set_mode(CAN_OP_LISTEN);
      lcd_gotoxy(1,1);
      lcd_putc_hexa(freq);
      
      for(i = 0; i < 8; i++)
      {
         delay_ms(500);
         if(can_loop()) return freq;
      }   
      output_toggle(LED2);
   }
   return 0xff;
}


void main()
{  
   //int1 inc_flag = 0b0;
   struct rx_stat rxstat;
   int32 rx_id;
   int32 tx_id;
   int8 rx_len;   
   
   int8 dadosEnv[8] = {0xAA,0x40},
        dadosRec[8],
        freq = 0,
        k = 0x00;
   //int8 teste[10] = {0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
   //int8 num[10] = {0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x3f};
   //int1 proximo = 0;
   //char k;

   //VEJA placa_plus.h
   set_tris_a(0b00001100);
   set_tris_b(0b00010001);
   set_tris_c(0b00010000);
   set_tris_d(0b00000000);
   
   output_high(LED1);
   delay_ms(200);
   output_low(LED1);
   delay_ms(200);
   output_high(LED1);
   delay_ms(200);
   output_low(LED1);
   delay_ms(200);
   
   output_low(LED1);
   output_low(LED2);

   //freq = read_eeprom(0x01);
   //set_freq_var(freq);
   
   lcd_init();
   lcd_cursor_on(1);
   lcd_putc("\fReady...\n"); delay_ms(500);
  
   can_init();
   
   can_set_mode(CAN_OP_CONFIG);
   can_set_id(RX0MASK,0x7BB,CAN_USE_EXTENDED_ID);
   can_set_id(RX0FILTER0,0x7BB,CAN_USE_EXTENDED_ID);
   can_set_id(RX0FILTER1,0x7BB,CAN_USE_EXTENDED_ID);
   can_set_id(RX1MASK,0x223,CAN_USE_EXTENDED_ID);
   can_set_id(RX1FILTER2,0x223,CAN_USE_EXTENDED_ID);
   can_set_id(RX1FILTER3,0x223,CAN_USE_EXTENDED_ID);
   can_set_id(RX1FILTER4,0x223,CAN_USE_EXTENDED_ID);
   can_set_id(RX1FILTER5,0x223,CAN_USE_EXTENDED_ID);

   //freq = detecta_freq();
   //lcd_putc_hexa(freq); delay_ms(500);
   
   can_set_mode(CAN_OP_LISTEN);   

   setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32);      //1,0 s overflow
   
   can_set_interr(0x03); //receive data only
   enable_interrupts(INT_EXT);
   enable_interrupts(INT_TIMER0);
   enable_interrupts(GLOBAL);

   lcd_send_byte(0,0x01);
   while(TRUE)
   {
      delay_ms(500);
      //output_toggle(LED2);
      
//!      if(can_kbhit())
//!      {
//!         if (can_getd (rx_id, dadosRec, rx_len, rxstat))
//!         {
//!            //output_toggle(LED1);
//!            
//!            //lcd_putc_hexa(interr);
//!            
//!            if(dadosRec[0] == 0xAA) output_high(LED2);
//!            else if(dadosRec[0] == 0xBB)output_low(LED2);
//!            lcd_gotoxy(1,2);
//!
//!            lcd_putc_hexa(rx_id);
//!            lcd_putc_hexa(dadosRec[0]);
//!         }   
//!      }
      //cd_putc(k);
      //lcd_gotoxy(1,2);
      lcd_putc_hexa(k);
      //lcd_gotoxy(1,1);
      k++;
      //delay_ms(500);
      //lcd_send_byte(0,0x04);
      //g_LcdX =- 2;
   }
}

